                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                       

import void Log_Lockpick(Critter&player,int lock,int force,int succes,string@param3,int[]@param4)from"gm";
import bool IsDoorAutomatic(uint pid)from"map_sutter_objects";

bool UseItemOnLocker(Critter&cr,Item&locker,Item&item)
{
	if(item.GetType()==(7))
	{
		
		if(item.LockerId==locker.LockerId)
		{
			if(!(((locker.LockerCondition)&((0x01)))!=0))
			{
				if((((locker.LockerCondition)&((0x02)))!=0))
				{
					(locker.LockerCondition=((locker.LockerCondition)&(~((0x02)))));
					cr.Say((11),"Вы отперли дверь.");
				}
				else
				{
					(locker.LockerCondition=(locker.LockerCondition)|((0x02)));
					cr.Say((11),"Вы заперли дверь.");
				}
				return true;
			}
			cr.Say((11),"Дверь должна быть закрыта.");
			return true;
		}
		else
		{
			cr.Say((11),"Ключ не подходит.");
			return true;
		}
	}
	
	return true;
}

import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";

bool UseSkillOnLocker(Critter&cr,Item&locker,int skill)
{
	Map@map=cr.GetMap();
	if(not(@map!=null))
	{
		cr.SayMsg((11),(3),(10202));
		return true;
	}
	
	if(cr.StatBase[(67)]>=(5)&&cr.StatBase[(67)]!=(10))
	{
		if(cr.IsNpc())
		{
			cr.DropPlanes();
			cr.ErasePlane((1),true);
			uint16 NpcX=cr.HexX;
			uint16 NpcY=cr.HexY;
			uint8 revDir;
			revDir=cr.Dir+3;
			if(revDir>5)
			revDir=revDir-6;
			map.MoveHexByDir(NpcX,NpcY,revDir,Random(5,10));
			AddWalkPlane(cr,0,cr.HexX,cr.HexY,revDir,false,0);
		}
		
		cr.Say((11),"Это Вам не под силу.");
		return true;
	}
	
	if(skill==(-1))
	{
		if((((locker.LockerCondition)&((0x20)))!=0)&&!(((locker.LockerCondition)&((0x01)))!=0)&&(locker.GetType()==(9)||locker.GetType()==(8)))
		{
			cr.RunClientScript("client_screen_codedoor@ShowScreen",locker.Id,locker.Val1,0,"Введите код",null);
			return true;
		}
		if(locker.GetType()==(9))
		{
			
			if((((locker.LockerCondition)&((0x10)))!=0))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if((((locker.LockerCondition)&((0x01)))!=0)&&(@map.GetCritter(locker.HexX,locker.HexY)!=null))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
			!(((locker.LockerCondition)&((0x08)))!=0)&&(((locker.LockerCondition)&((0x02)))!=0))
			{
				cr.SayMsg((11),(3),(10100));
				LockerBudge(locker);
				return true;
			} 
			
			if(locker.Val6==0&&IsDoorAutomatic(locker.GetProtoId()))
			{
				cr.Say((11),"Энергоснабжение отключено. Дверь заблокированна.");
				return true;
			} 
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			locker.LockerClose();
			else
			locker.LockerOpen();
		}
		else if(locker.GetType()==(8))
		{
			if((((locker.Flags)&((0x08000000)))!=0))
			{
				
				int freeWeight=cr.Stat[(11)]-cr.ItemsWeight(),
				contWeight=0;
				Item@[]items;
				uint len=locker.GetItems(-1,items);
				for(uint i=0;i<len;i++)
				{
					if(items[i]is null)
					continue;
					
					contWeight+=int(items[i].Proto.Weight*items[i].GetCount());
				}
				
				if(freeWeight>=(contWeight+int(locker.Proto.Weight)))
				{
					MoveItem(locker,0,cr);
					
					return true;
				}
				
			}
			
			if((((locker.LockerCondition)&((0x10)))!=0))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
			!(((locker.LockerCondition)&((0x08)))!=0)&&!IsKeyAviable(cr,locker.LockerId))
			{
				cr.SayMsg((11),(3),(10100));
				LockerBudge(locker);
				return true;
			} 
			
			if(locker.Proto.Container_Changeble)
			{
				
				if((((locker.LockerCondition)&((0x01)))!=0))
				locker.LockerClose();
				else
				{
					locker.LockerOpen();
					cr.ParamBase[(130)]=locker.Id;
					cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
				}
			}
			else
			{
				cr.ParamBase[(130)]=locker.Id;
				cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
			}
		}
	}
	else if(skill==(210))
	{
		if(locker.GetType()==(8)&&
		((!locker.Proto.Container_Changeble&&(((locker.Flags)&((0x08000000)))!=0)&&locker.Accessory==(2))||
		(((locker.LockerCondition)&((0x01)))!=0)))
		{
			cr.ParamBase[(130)]=locker.Id;
			cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
		}
		else
		cr.SayMsg((11),(3),(10202));
	}
	else if(skill==(209))
	{ 
		
		if((((locker.LockerCondition)&((0x10)))!=0))
		{
			cr.SayMsg((11),(3),(10202));
			return true;
		}
		
		if(cr.Timeout[(234)]>0)
		{
			cr.SayMsg((11),(3),(3401));
			return true;
		}
		
		int base=cr.Skill[(209)]-locker.LockerComplexity;
		Item@lockpick=cr.GetItem(0,(1));
		if(locker.Val0==4&&(@lockpick!=null)&&lockpick.GetProtoId()!=(77))
		{
			cr.Say((11),"Нужна электроная отмычка.");
			return false;
		}  
		
		if(cr.GetAccess()!=(3))
		base=(((base)>(95))?(95):(((base)<(0))?(0):(base)));
		
		if(locker.LockerComplexity==300&&cr.GetAccess()!=(3))
		cr.SayMsg((11),(3),(3440));
		else if(locker.LockerCondition==(0x20))
		{
			uint16 complex=locker.LockerComplexity;
			uint16 exp=complex*2;
			
			string tempCode=locker.Val4;
			uint8 codeLength=tempCode.length();
			uint16 skillLock=cr.Skill[(209)];
			uint8 count=complex/codeLength;
			
			bool changeCode=true;
			
			for(uint8 i=0;i<codeLength;i++)
			{ 
				
				skillLock=(skillLock>=count?(skillLock-count):0);
				if(complex>=skillLock)
				{
					tempCode[i]=42;
					exp=(exp>=count*4?exp-(count*4):0);
					
					changeCode=false;
				}
			}
			
			cr.Say((11),"Код двери : "+tempCode);
			
			if(changeCode&&complex/2<=cr.Skill[(212)])
			{
				exp+=complex;
				cr.RunClientScript("client_screen_codedoor@ShowScreen",locker.Id,locker.Val1,1,"Введите новый код.\nДлинна "+(locker.Val1+1),null);
			}
			
			cr.StatBase[(76)]+=exp;
			
		}
		else
		{
			cr.StatBase[(90)]=locker.Id;
			cr.ShowScreen((2),3,"answer_LOCKPICK");
			cr.Say((18),"Выберите действие");
			cr.Say((19+(0)),"постучать");
			cr.Say((19+(1)),"выбить");
			cr.Say((19+(2)),"начать взлом");
			return true;
		}
		
		cr.TimeoutBase[(234)]=(__FullSecond+((30)*__TimeMultiplier));
	}
	else if(skill==(-4))
	{
		return false;
	}
	else
	{
		cr.SayMsg((11),(3),(10202));
	}
	return true;
}

void answer_LOCKPICK(Critter&player,uint answerI,string&answerS)
{
	Item@lock=GetItem(player.Stat[(90)]);
	if(lock is null)
	return;
	Item@lockpick=player.GetItem(0,(1));
	
	if(answerI==0)
	{
		Map@map=player.GetMap();
		map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"тук-тук");
		player.Say((11),"Вы постучали в дверь.");
	}
	if(answerI==1)
	{
		Map@map=player.GetMap();
		map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0xC8)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),"УДАР");
		
		if(!(((lock.LockerCondition)&((0x01)))!=0)&&lock.Val0!=3&&!IsDoorAutomatic(lock.GetProtoId()))
		{
			if(Random(lock.LockerComplexity+50,350)<player.Stat[(0)]*player.Skill[(203)]/8&&player.Stat[(77)]>=12)
			{
				lock.LockerOpen();
				player.Say((6),"Мощным ударом выбивает дверь");
			}
			
			else if(player.Stat[(77)]<=11)
			{
				player.Say((11),"Вы сильно врезали по замку, но без какого либо эфекта.");
			}}
		else
		{
			player.Say((11),"Здесь это не поможет.");
		}       
		
		Log_Lockpick(player,player.Stat[(90)],1,0,null,null);
		
		return;
	}
	if(answerI==2)
	{
		if((((lock.LockerCondition)&((0x01)))!=0))
		{
			player.Say((11),"Дверь и так открыта.");
			return;
		}
		if(lock.Val0==0)
		{
			player.Say((11),"Нет замка.");
			return;
		}
		if(lock.Val0==1)
		{
			lock.Val5=Random(10,99);
			lock.Val4=10;
		}
		if(lock.Val0==2)
		{
			if(!(@lockpick!=null)||(lockpick.GetProtoId()!=(410)&&lockpick.GetProtoId()!=(84)))
			{
				player.Say((11),"Нужны отмычки.");
				return;
			}
			lock.Val5=Random(100,999);
			lock.Val4=100;
		}
		if(lock.Val0==3)
		{
			if(!(@lockpick!=null)||lockpick.GetProtoId()!=(410))
			{
				player.Say((11),"Нужен большой набор отмычек.");
				return;
			}
			lock.Val5=Random(1000,9999);
			lock.Val4=1000;
		}
		if((@lockpick!=null)&&lockpick.Val0!=0&&(lockpick.GetProtoId()==(410)||lockpick.GetProtoId()==(84)))
		{
			DeleteItem(lockpick);
			player.Say((11),"Отмычка сломалась, видимо ее неудачно вытащили ее из замка в прошлый раз.");
			return;
		}
		else if((@lockpick!=null)&&Random(0,1)==0)
		lockpick.Val0=10;
		player.StatBase[(91)]=1;
		player.StatBase[(92)]=0;
		
		player.ShowScreen((2),7,"answer_LOCKPICK_lock");
		player.Say((18),"Состояние замка неизвестно");
		player.Say((19+(0)),"Осмотреть замок");
		player.Say((19+(1)),"Щуп дальше");
		player.Say((19+(2)),"Щуп назад");
		player.Say((19+(3)),"Щуп вверх");
		player.Say((19+(4)),"Щуп вниз");
		player.Say((19+(5)),"Повернуть");
		player.Say((19+(6)),"Вынуть отмычку");
		Log_Lockpick(player,player.Stat[(90)],0,0,null,null);
		player.TimeoutBase[(234)]=(__FullSecond+((30)*__TimeMultiplier));
	}
}

void answer_LOCKPICK_lock(Critter&player,uint answerI,string&answerS)
{
	Item@lock=GetItem(player.Stat[(90)]);
	if(lock is null)
	return;
	Map@map=player.GetMap();
	int base=player.Skill[(209)]-lock.LockerComplexity;
	base=(((base)>(95))?(95):(((base)<(5))?(5):(base)));
	Item@lockpick=player.GetItem(0,(1));
	
	string state="";
	string comb=lock.Val4;
	int curPos=0,curComb=0;
	
	if(answerI==0)
	{
		if(lock.Val0<2)
		state="Замок так себе, ";
		if(lock.Val0==2)
		state="Замок в хорошем состоянии, ";
		if(lock.Val0==3)
		state="Очень хороший замок, ";
	}
	if(answerI==1)
	{
		if(player.Timeout[(244)]>((2)*__TimeMultiplier*60))
		state="Щуп застрял, нужно чуть ослабить зажим и попробовать еще раз, ";
		else if(player.StatBase[(91)]<lock.Val0+1)
		{
			player.StatBase[(91)]++;
			state="Вы продвинули щуп дальше, ";
			if(Random(0,2)==0)
			player.TimeoutBase[(234)]=__FullSecond+((2)*__TimeMultiplier);
		}
		else
		state="Щуп уперся и дальше в замок не продвигается, ";
	}
	if(answerI==2)
	{
		if(player.Timeout[(234)]>((2)*__TimeMultiplier*60))
		state="Щуп застрял, нужно чуть ослабить зажим и попробовать еще раз, ";
		else if(player.StatBase[(91)]>1)
		{
			player.StatBase[(91)]--;
			state="Вы отодвинули щуп назад, ";
			if(Random(0,2)==0)
			player.TimeoutBase[(234)]=__FullSecond+((2)*__TimeMultiplier);
		}
		else
		state="Щуп уже в крайнем положении, остается только вытащить его, ";
	}
	if(answerI==3)
	{
		curPos=(lock.Val4%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
		if(curPos<9)
		{
			curComb=(lock.Val5%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
			lock.Val4+=pow(10,player.StatBase[(91)]-1);
			curPos++;
			state="Вы подвинули щупом язычек замка вверх, ";
			if(player.Timeout[(234)]>0&&Random(0,2)==0)
			{
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы поторопились и неловко дернули щупом, ";
				if(Random(0,1)==0)
				{
					int bar=Random(1,lock.Val0+1);
					curComb=(lock.Val5%pow(10,bar))/pow(10,bar-1);
					lock.Val5+=(Random(0,9)-curComb)*pow(10,bar-1);
				}
			}
			else if(curComb==curPos&&base>Random(0,100))
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if((curComb==(curPos-1)||curComb==(curPos+1))&&base>Random(0,100)&&Random(0,1)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if((curComb==(curPos-2)||curComb==(curPos+2))&&base>Random(0,100)&&Random(0,3)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if(base<Random(0,100)&&Random(0,9)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			player.TimeoutBase[(234)]=__FullSecond+((10-player.Skill[(209)]*0.03)*__TimeMultiplier);
		}
		else
		state="Щуп уперся, пружина язычка уже максимально зажата, ";
	}
	if(answerI==4)
	{
		curPos=(lock.Val4%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
		if(curPos>1||(curPos>=1&&player.StatBase[(91)]>=(lock.Val0+1)))
		{
			curComb=(lock.Val5%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
			lock.Val4-=pow(10,player.StatBase[(91)]-1);
			curPos--;
			state="Вы подвинули щупом язычек замка вниз, ";
			if(player.Timeout[(234)]>((2)*__TimeMultiplier*60))
			{
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы поторопились и неловко дернули щупом, ";
				if(Random(0,1)==0)
				{
					int bar=Random(1,lock.Val0+1);
					curComb=(lock.Val5%pow(10,bar))/pow(10,bar-1);
					lock.Val5+=(Random(0,9)-curComb)*pow(10,bar-1);
				}
			}
			else if(curComb==curPos&&base>Random(0,100))
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if((curComb==(curPos-1)||curComb==(curPos+1))&&base>Random(0,100)&&Random(0,1)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if((curComb==(curPos-2)||curComb==(curPos+2))&&base>Random(0,100)&&Random(0,3)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			else if(base<Random(0,100)&&Random(0,9)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчек, ";
			}
			player.TimeoutBase[(234)]=__FullSecond+((10-player.Skill[(209)]*0.03)*__TimeMultiplier);
		}
		else
		state="Щуп уперся, пружина язычка уже максимально отжата, ";
	}
	if(answerI==5)
	{       
		
		if(lock.Val4==lock.Val5)
		{
			lock.LockerOpen();
			if(lock.GetType()==(8))
			{
				player.ShowContainer(null,lock,lock.Proto.GroundLevel?(2):(1));
			}
			else
			player.Say((11),"Вы успешно вскрыли замок. Осторожно, дверь может захлонуться.");
			lock.Update();
			player.AddScore((18),1);
			if((@lockpick!=null))
			lockpick.Val0=0;
			Log_Lockpick(player,player.Stat[(90)],0,1,null,null);
			return;
		}
		else if(player.StatBase[(92)]<Random(0,player.Skill[(209)]*0.05))
		{
			state="Замок не поворачивается, ";
			player.StatBase[(92)]++;
		}
		else
		{
			player.SayMsg((11),(3),(3440));
			if((@lockpick!=null)&&Random(0,1)==0)
			lockpick.Val0=0;
			return;
		}
	}
	if(answerI==6)
	{
		if(player.StatBase[(91)]>1)
		state="Сначала выдвините щуп в первую позицию, ";
		else
		{
			lockpick.Val0=0;
			player.Say((11),"Вы аккуратно вытащили отмычку из замка.");
			return;
		}
	}
	
	player.Say((6),"возится с замком");
	state+="позиция щупа - "+player.StatBase[(91)];
	player.ShowScreen((2),7,"answer_LOCKPICK_lock");
	player.Say((18),state);
	player.Say((19+(0)),"Осмотреть замок");
	player.Say((19+(1)),"Щуп дальше");
	player.Say((19+(2)),"Щуп назад");
	player.Say((19+(3)),"Щуп вверх");
	player.Say((19+(4)),"Щуп вниз");
	player.Say((19+(5)),"Повернуть");
	player.Say((19+(6)),"Вынуть отмычку");
}

bool IsKeyAviable(Critter&cr,uint lockerId)
{
	if(lockerId==0)
	return true;
	if((0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return true;
	Item@[]keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return true;
	return false;
}

uint GetKeyId(Critter&cr,uint lockerId)
{
	if(lockerId==0||(0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return 0;
	Item@[]keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return keys[i].Id;
	return 0;
}

void SwitchState(Item&locker)
{ 
	
	if(locker.GetType()==(9)||locker.GetType()==(8))
	{
		
		if(not(((locker.LockerCondition)&((0x10)))!=0))
		{
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			locker.LockerClose();
			else
			locker.LockerOpen();
		}
	}
}

void LockerBudge(Item&item)
{
	Map@map=GetMap(item.MapId);
	if(!(@map!=null))
	return;
	string sound=item.GetType()==(9)?"SLDOORSC.ACM":"ILCNTNRB.ACM";
	
	map.PlaySound(sound,item.HexX,item.HexY,8);
}

