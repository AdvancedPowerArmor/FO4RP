                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

import void FlushScreen(Critter&cr,bool fadeOut,uint timeMs)from"effects";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";
import int NextLevelNeedExp(Critter&cr)from"parameters";         

int RollVsSkill(Critter&cr,uint skillIndex,int bonus)
{
	int skVal=cr.Skill[skillIndex];
	int r=Random(1,100);
	
	if(skVal+bonus>=r)
	{
		if(Random(1,100)<=(((skVal-r)/10)+cr.StatBase[(14)]))
		return(3);
		else
		return(2);
	}
	else
	{
		if(Random(1,100)<=(r-skVal)/10)
		return(0);
		else
		return(1);
	}
}

bool IsSuccessRvS(int val)
{
	return val==(3)||val==(2);
}

bool IsCriticalRvS(int val)
{
	return val==(3)||val==(0);
}

void HealCritter(Critter&player)
{
	if(player.IsDead())
	player.ToLife();
	player.StatBase[(72)]=player.Stat[(7)];
}

bool TransitToLoc(Critter&cr,uint16 locPid,uint mapIndex,uint entranceNum)
{
	Location@loc=GetLocationByPid(locPid,0);
	if(not(@loc!=null))
	return false;
	
	Map@map=loc.GetMapByIndex(mapIndex);
	if(not(@map!=null))
	return false;
	
	FlushScreen(cr,true,3000);
	return cr.TransitToMap(map.Id,entranceNum);
}

bool TransitToMap(Critter&cr,uint16 mapPid,uint entranceNum)
{
	Map@map=GetMapByPid(mapPid,0);
	if(not(@map!=null))
	return false;
	
	FlushScreen(cr,true,3000);
	return cr.TransitToMap(map.Id,entranceNum);
}

bool TransitToNewLocation(Critter&cr,uint16 locPid)
{
	Critter@[]group={cr};
	
	uint locId=CreateLocation(locPid,cr.WorldX,cr.WorldY,group);
	if(locId==0)
	return false;
	
	Location@loc=GetLocation(locId);
	loc.Visible=false;
	loc.GeckVisible=false;
	loc.AutoGarbage=true;
	
	FlushScreen(cr,true,3000);
	return cr.TransitToMap(loc.GetMapByIndex(0).Id,0);
}

void InfoMessage(Critter&player,Critter&npc,uint strNum)
{
	player.SayMsg((11),(1),(1000000000+(npc.Stat[(104)])*100000+(strNum)));
}

void NpcMessageNorm(Critter&npc,uint strNum)
{
	npc.SayMsg((2),(1),(1000000000+(npc.Stat[(104)])*100000+(strNum)));
}

void NpcMessageShout(Critter&npc,uint strNum)
{
	npc.SayMsg((4),(1),(1000000000+(npc.Stat[(104)])*100000+(strNum)));
}

void NpcMessageWhisp(Critter&npc,uint strNum)
{
	npc.SayMsg((8),(1),(1000000000+(npc.Stat[(104)])*100000+(strNum)));
}

void NpcMessageEmo(Critter&npc,uint strNum)
{
	npc.SayMsg((6),(1),(1000000000+(npc.Stat[(104)])*100000+(strNum)));
}

void TimeoutSet(Critter&npc,int timeoutNumber,uint gameMinutes)
{
	int variable=0;
	switch(timeoutNumber)
	{
		case 0:
		variable=(6160);
		break;
		case 1:
		variable=(6161);
		break;
		case 2:
		variable=(6162);
		break;
		case 3:
		variable=(6163);
		break;
		case 4:
		variable=(6164);
		break;
		case 5:
		variable=(6165);
		break;
		case 6:
		variable=(6166);
		break;
		case 7:
		variable=(6167);
		break;
		case 8:
		variable=(6168);
		break;
	}
	GameVar@t=GetLocalVar(variable,npc.Id);
	t=__FullSecond+gameMinutes*60;
}

void TimeoutSub(Critter&npc,uint gameMinutesSub)
{
	GameVar@t=GetLocalVar((6160),npc.Id);
	t-=gameMinutesSub*60;
}

void TimeoutAdd(Critter&npc,uint gameMinutesAdd)
{
	GameVar@t=GetLocalVar((6160),npc.Id);
	t+=gameMinutesAdd*60;
}

void GroupSetVar(Critter&player,uint16 varId,int value)
{
	Critter@[]group={player};
	player.GetFollowGroup((0x0F),group);
	for(uint i=0,j=group.length();i<j;i++)
	{
		GameVar@var=GetLocalVar(varId,group[i].Id);
		if(not(@var!=null))
		return;
		var=value;
	}
}

void Warn(Critter&player,int npcRole)
{
	if(not player.IsPlayer())
	return;
	
	Critter@npc=GetNearCritterWithRole(player.GetMap(),player.HexX,player.HexY,(10),npcRole);
	if(not(@npc!=null))
	return;
	
	npc.SayMsg((2),(0),1001);
}

void DoorControl(Critter&player,uint entireNum,bool toOpen)
{
	Map@map=player.GetMap();
	uint16 x=0,y=0;
	if((@map!=null)&&map.GetEntireCoords(entireNum,0,x,y))
	{
		Item@door=map.GetDoor(x,y);
		if((@door!=null))
		{
			if(toOpen)
			door.LockerOpen();
			else
			door.LockerClose();
		}
	}
}

bool DialogNpc(Critter&player,int role)
{
	if(not player.IsPlayer())
	return false;
	
	Critter@npc=GetNearCritterWithRole(player.GetMap(),player.HexX,player.HexY,(10),role);
	if(not(@npc!=null))
	return false;
	
	player.Wait(0);
	return RunDialog(player,npc,true);
}

Critter@GetNearCritterWithRole(Map@map,uint16 hexX,int hexY,uint radius,int role)
{
	Critter@[]critters;
	uint count=map.GetCrittersHex(hexX,hexY,radius,(0x01),critters);
	uint minDist=10000;
	Critter@nearCrit=null;
	for(uint i=0;i<count;i++)
	{
		if(critters[i].StatBase[(89)]==role)
		{
			uint d=GetDistantion(hexX,hexY,critters[i].HexX,critters[i].HexY);
			if(d<minDist)
			{
				minDist=d;
				@nearCrit=critters[i];
			}
		}
	}
	return nearCrit;
}                                                                                                                               

