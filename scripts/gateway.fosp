                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

uint[]guards;

import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)from"npc_planes";
import uint EraseAttackPlane(Critter&npc,Critter&target)from"npc_planes";

void t_EnterHex(Critter&cr,Scenery&trigger,bool entered,uint8 dir,int val)
{
	if(cr.IsNpc())
	return;
	
	int ck=cr.ParamBase[(703)];
	
	GameVar@citizenship=GetLocalVar((7300),cr.Id);
	GameVar@border_mode=GetGlobalVar((7343));
	GameVar@faction=GetLocalVar((9971),cr.Id);
	
	if(entered&&border_mode.GetValue()!=5&&(citizenship.GetValue()<=1&&cr.Param[(701)]==0||
	citizenship.GetValue()==10||
	(border_mode.GetValue()==1&&citizenship.GetValue()<=2)||
	(border_mode.GetValue()==2&&citizenship.GetValue()<=3)||
	(border_mode.GetValue()==3&&citizenship.GetValue()<=3)||
	(border_mode.GetValue()==4&&(faction.GetValue()==0||faction.GetValue()>=3))))
	{
		
		if(val==5)
		{
			if(border_mode.GetValue()<=2&&citizenship.GetValue()==1)
			{
				if(border_mode.GetValue()==0&&(cr.Dir==0||cr.Dir==5||cr.Dir==4))
				{
					cr.Say((6),"показывает пропуск");
					return;
				}
				else if(cr.Dir==1||cr.Dir==2||cr.Dir==3)
				{
					citizenship.opAssign(0);
					cr.Say((6),"сдает пропуск охране");
					return;
				}
				else
				AttackAndCatch(cr);
			}
			else if(border_mode.GetValue()<=2&&citizenship.GetValue()==2&&(cr.Dir==1||cr.Dir==2||cr.Dir==3))
			return;
			else
			AttackAndCatch(cr);
		}
		else if(val==4)
		{
			if(citizenship.GetValue()==1&&border_mode.GetValue()==0)
			return;
			
			Critter@gu=null;
			for(uint i=0,len=guards.length();i<len;i++)
			{
				Critter@tgu=GetCritter(guards[i]);
				if((tgu is null)||GetDistantion(cr.HexX,cr.HexY,tgu.HexX,tgu.HexY)>15||!tgu.IsSee(cr))
				continue;
				@gu=tgu;
				if(tgu.Param[(104)]==330)
				break;
			}
			if(gu is null)
			return;  
			
			uint8 dir=GetDirection(gu.HexX,gu.HexY,cr.HexX,cr.HexY);    
			
			if(cr.Dir==dir||cr.Dir==((dir+1)%6)||cr.Dir==(dir+5)%6)
			return;  
			
			gu.Say((4),"—то€ть! “ебе нельз€ в город!");
			
			gu.SetDir(dir);
			
			cr.SetEvent((0),null);
			cr.Wait(1000);
		}
	}  
	
}

void AttackAndCatch(Critter&cr)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	for(uint i=0;i<guards.length();i++)
	{
		Critter@guard=GetCritter(guards[i]);
		if(guard is null)
		continue;
		
		uint len=GetDistantion(cr.HexX,cr.HexY,guard.HexX,guard.HexY);
		if(len>25||!guard.IsSee(cr)||(cr.GetMap().Id!=guard.GetMap().Id))
		continue;
		
		AddAttackPlane(guard,0,cr,-10);
	}
	
	if(cr.Param[(703)]!=(3)&&cr.Stat[(67)]!=(29))
	cr.SetEvent((25),"_KoAndCatch");
	
}

void _KoAndCatch(Critter&cr,uint anim2begin,uint anim2idle,uint anim2end,uint lostAp,uint knockDist)
{
	int ck=cr.ParamBase[(703)];
	
	bool ck2=false;
	
	if(!cr.IsDead())
	{
		for(uint i=0;i<guards.length();i++)
		{
			Critter@guard=GetCritter(guards[i]);
			
			if((guard is null))
			continue;
			if(cr.GetMap().Id!=guard.GetMap().Id)
			continue;
			
			EraseAttackPlane(guard,cr);
			
			if(ck2||(!guard.IsSee(cr)))
			continue;
			
			if(!catch(cr))
			Log("Fail with catch!");
			
			ck2=true;
		}
	}
	
	cr.SetEvent((25),null);
}

bool catch(Critter&cr)
{
	
	Map@map=cr.GetMap();
	if(map is null)
	return false;
	Location@loc=map.GetLocation();
	if((loc.GetProtoId()>=1&&loc.GetProtoId()<=4)||loc.GetProtoId()==6)
	{
		Map@map2=GetLocationByPid(5,0).GetMapByIndex(0);
		if(map2 is null)
		{
			Log("gw map");
			return false;
		}
		bool ch=false;
		ch=cr.TransitToMap(map2.Id,0);
		return ch;
	}
	
	bool ch=false;
	ch=cr.TransitToHex(120+Random(-5,5),240+Random(-5,5),2);
	cr.Say((11),"вас выкинули из города");
	return ch;                                 
	
}

void addGuard(Critter&npc)

{
	guards.insertLast(npc.Id);   
	
} 

void r_toHex(Critter&master,Critter@slave,int val)
{
	Map@map=master.GetMap();
	
	if(map is null)
	return;
	
	uint16 hexX=0,hexY=0;
	
	if(!map.GetEntireCoords(val,0,hexX,hexY))
	return;
	
	master.TransitToHex(hexX,hexY,5);
}

bool d_isGoOut(Critter&master,Critter@slave)
{
	Map@map=master.GetMap();
	
	if(map is null)
	return false;
	
	uint16 hexX=0,hexY=0;
	
	if(!map.GetEntireCoords(83,0,hexX,hexY))
	return false;
	
	if(master.HexX==hexX&&master.HexY==hexY)
	return true;
	
	uint8 dir=GetDirection(master.HexX,master.HexY,hexX,hexY);
	
	return(dir>0&&dir<4);
	
}

void AttackAndCatch(Critter&player,int id,int param1,int param2)
{
	Critter@cr=GetCritter(uint(id));
	if(cr is null)
	return;
	AttackAndCatch(cr);
}

void Release(Critter&player,int id,int param1,int param2)
{
	Critter@cr=GetCritter(id);
	if(cr is null)
	return;
	Map@map=cr.GetMap();
	if(map is null||map.GetProtoId()!=18)
	return;
	if(cr.HexX>=120||cr.HexX<=100||cr.HexY>=220||cr.HexY<=210)
	return;       
	
	cr.TransitToHex(player.HexX+1,player.HexY+1,5);
	Item@toCont=map.GetItem(117,208,188);
	if((@toCont!=null))
	{
		Item@[]items;
		toCont.GetItems(cr.Id,items);
		
		MoveItems(items,cr);
		
		player.Say((11),"Item return ok.");
	}
}
