                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

import void DropBleed(Critter&cr)from"critter_status";
import void DropToxic(Critter&cr)from"critter_status";

import void Prolonged_Doc(Critter&targetCr,uint16 doctime,uint16 damage)from"heal";
import void Prolonged_heal(Critter&targetCr,uint16 sk)from"heal";                     

void WaterPumpInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_WaterPumpSkill");
	item.SetEvent((3),"_WaterPumpOnMe");
}

const uint[]bottlePid={(542),(532)};
const uint[]bottleFull={(1627),(533)};
const uint[]ALLamapPids={(89),(59),(31),(31),(28),(29),(32),(33)};
const uint[]Phoenix_mapPids={(31)};
const uint[]mapPids={(89),(59),(31),(28),(29),(32),(33)};
const uint[]mapLight={(88),(89),(59),(31),(28),(29),(32),(33)};

bool _WaterPumpSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==(31))@power=GetGlobalVar((9997));
		
		uint8 switcher=item.Val2;
		
		uint16 parts=item.Val4;
		uint16 repair=item.Val5;
		uint16 science=item.Val6;
		
		if(science>0){cr.Say((11),"Требуется внимательный осмотр.");return true;}
		if(parts>0){cr.Say((11),"Требуется деталь:");cr.SayMsg((11),(2),parts*100);return true;}
		if(repair>0){cr.Say((11),"Требуется ремонт.");return true;} 
		
		if(power.GetValue()>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			string msg="";
			
			if(val>0)
			{
				msg="Включено";
			}
			else
			{
				msg="Выключено";
			}
			
			item.Val2=val;
			
			cr.Say((11),""+msg+". Вода "+(val>0?"":"не")+" очищается.");
		}
		else
		{
			cr.Say((11),"Энергоснабжение отклчено. Запустите генератор сначала.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(item,cr))return true;
		
		int val=item.Val2;
		
		string msg="";
		
		if(val>0)
		{
			msg="включено";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&item.Val5>0)
	{
		if(!check_repair(item,cr))return true;
	}
	return true;
}

bool _WaterPumpOnMe(Item&item,Critter&cr,Item@usedItem)
{
	
	if(usedItem is null)
	return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(!check_parts(item,cr,usedItem))return true;
	
	int8 index=bottlePid.find(pid);
	
	if(index!=-1)
	{
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint8 switcher=item.Val2;
		uint8 water=item.Val3;
		
		if(power.GetValue()>0)
		{
			if(switcher>0)
			{
				if(water>0)
				{
					do{if(usedItem.GetCount()>(1))
						usedItem.SetCount(usedItem.GetCount()-(1));else
						DeleteItem(usedItem);}while(false);
					cr.AddItem(bottleFull[index],1);
					item.Val3--;
				}
				else
				{
					cr.Say((11),"Воды больше нет.");
				}
			}
			else
			{
				cr.Say((11),"Помпа отключена. Включите ее сначала.");
			}
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
		
		return true;
	}
	
	return false;
}

void WattsInit(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_WattsSkill");
	item.SetEvent((3),"_WattsOnMe");
}

bool _WattsSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint8 offpower=item.Val1;
		uint8 switcher=item.Val2;
		
		uint16 parts=item.Val4;
		uint16 repair=item.Val5;
		uint16 science=item.Val6;
		
		if(science>0){cr.Say((11),"Требуется внимательный осмотр.");return true;}
		if(parts>0){cr.Say((11),"Требуется деталь:");cr.SayMsg((11),(2),parts*100);return true;}
		if(repair>0){cr.Say((11),"Требуется ремонт.");return true;}
		
		if(power.GetValue()>0||offpower>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			item.Val2=val;
			
			string msg="";
			
			if(val>0)
			{
				msg="включен";
				power.opAddAssign(offpower);
				item.Val1=0;
			}
			else
			{
				msg="выключен";
				item.Val1=power.GetValue();
				power.opAssign(0);
			}
			
			if(cr.GetMap().GetProtoId()==(31))WattsReleasePhoenix(val);
			else WattsRelease(val);
			
			cr.Say((11),"Генератор "+msg+".");
		}
		else
		{
			cr.Say((11),"Кончился заряд. Зарядите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(item,cr))return true;
		
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint8 switcher=item.Val2;
		
		int val=switcher;
		
		string msg="",addMsg="";
		
		if(val>0)
		{
			msg="включен";
			addMsg=" Уровень заряда генератора : "+power.GetValue()+" .";
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+"."+addMsg);
	}
	else if(skill==(213)&&item.Val5>0)
	{
		if(!check_repair(item,cr))return true;
	}
	
	return true;
}

bool _WattsOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	if(!check_parts(item,cr,usedItem))return true;
	
	if(usedItem.GetProtoId()!=(39))
	return false;
	
	uint8 switcher=item.Val2;
	
	if(switcher==0)item.Val1+=20;
	else
	{
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==(31))@power=GetGlobalVar((9997));
		power.opAddAssign(20);
	}
	
	do{if(usedItem.GetCount()>(1))
		usedItem.SetCount(usedItem.GetCount()-(1));else
		DeleteItem(usedItem);}while(false);
	
	cr.Say((11),"Вы подзарядили генератор.");
	
	return true;
}

void WattsRelease(int val)
{
	for(uint8 i=0;i<mapPids.length();++i)
	{
		Map@map=GetMapByPid(mapPids[i],0);
		if(map is null)
		continue;
		
		map.SetData((24),val);
	}
	
	for(uint8 i=0,j=mapLight.length();i<j;++i)
	{
		Map@map=GetMapByPid(mapLight[i],0);
		if(map is null)
		continue;
		
		Item@[]light;
		
		map.GetItems((1305),light);
		
		for(uint8 ii=0,jj=light.length();ii<jj;++ii)
		{
			Item@item=light[ii];
			if(item is null)
			continue;
			
			bool switcher=(val>0);
			
			if(switcher)
			{  
				
				item.LightIntensity=100;
			}
			else
			{  
				
				item.LightIntensity=-1;
			}
			item.Update();
		}
	}
}

void WattsReleasePhoenix(int val)
{
	for(uint8 i=0;i<Phoenix_mapPids.length();++i)
	{
		Map@map=GetMapByPid(Phoenix_mapPids[i],0);
		if(map is null)
		continue;
		
		map.SetData((24),val);
	}
	
	for(uint8 i=0,j=Phoenix_mapPids.length();i<j;++i)
	{
		Map@map=GetMapByPid(Phoenix_mapPids[i],0);
		if(map is null)
		continue;
		
		Item@[]light;
		
		map.GetItems((1305),light);
		
		for(uint8 ii=0,jj=light.length();ii<jj;++ii)
		{
			Item@item=light[ii];
			if(item is null)
			continue;
			
			bool switcher=(val>0);
			
			if(switcher)
			{
				item.LightIntensity=100;
			}
			else
			{
				item.LightIntensity=-1;
			}
			item.Update();
		}
	}
}  

bool IsDoorAutomatic(uint pid)
{
	bool automat=(pid==2142||pid==2143||pid==3169||pid==3170||pid==4763||pid==4765);
	
	return automat;
}

void AirLockInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_AirLockSkill");
	item.SetEvent((3),"_AirLockOnMe");
}

bool _AirLockSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint16 parts=item.Val4;
		uint16 repair=item.Val5;
		uint16 science=item.Val6;
		
		if(science>0){cr.Say((11),"Требуется внимательный осмотр.");return true;}
		if(parts>0){cr.Say((11),"Требуется деталь:");cr.SayMsg((11),(2),parts*100);return true;}
		if(repair>0){cr.Say((11),"Требуется ремонт.");return true;}
		
		uint8 switcher=item.Val2;
		
		if(power.GetValue()>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			string msg="";
			
			if(val>0)
			{
				msg="Включено";
			}
			else
			{
				msg="Выключено";
			}
			
			item.Val2=val;
			cr.Say((11),""+msg+". Воздух "+(val>0?"":"не")+" поступает.");
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(item,cr))return true;
		
		uint8 switcher=item.Val2;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включено";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&item.Val5>0)
	{
		if(!check_repair(item,cr))return true;
	}
	
	return true;
}

bool _AirLockOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(!check_parts(item,cr,usedItem))return true;
	
	return false;
}

void DocInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_DocSkill");
	item.SetEvent((3),"_DocOnMe");
}

bool _DocSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint16 parts=item.Val4;
		uint16 repair=item.Val5;
		uint16 science=item.Val6;
		
		if(science>0){cr.Say((11),"Требуется внимательный осмотр.");return true;}
		if(parts>0){cr.Say((11),"Требуется деталь:");cr.SayMsg((11),(2),parts*100);return true;}
		if(repair>0){cr.Say((11),"Требуется ремонт.");return true;}
		
		uint8 charge=item.Val3;
		
		if(power.GetValue()>0)
		{
			if(charge>0)
			{
				DocHeal(cr);
				
				charge--;
				charge=(((charge)>(100))?(100):(((charge)<(0))?(0):(charge)));
				item.Val3=charge;
			}
			else
			{
				cr.Say((11),"Закончился биогель, обновите резервуар.");
			}
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(item,cr))return true;
		
		GameVar@power=GetGlobalVar((9996));
		if(cr.GetMap().GetProtoId()==31)@power=GetGlobalVar((9997));
		
		uint8 charge=item.Val3;
		
		string msg="",addMsg="";
		
		if(power.GetValue()>0)
		{
			msg="включено";
			addMsg=" Биогеля хватит на "+charge+" операций.";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+"."+addMsg);
	}
	else if(skill==(213)&&item.Val5>0)
	{
		if(!check_repair(item,cr))return true;
	}
	
	return true;
}

bool _DocOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	if(!check_parts(item,cr,usedItem))return true;
	
	if(usedItem.GetProtoId()!=(440))
	return false;
	
	GameVar@power=GetGlobalVar((9996));
	
	uint8 charge=item.Val3;
	
	if(charge==0)
	{
		
		item.Val3=100;
		do{if(usedItem.GetCount()>(1))
			usedItem.SetCount(usedItem.GetCount()-(1));else
			DeleteItem(usedItem);}while(false);
		
		cr.Say((11),"Вы залили биогель в резервуар.");
	}
	else
	{
		cr.Say((11),"Биогель пока не требуется.");
	}
	
	return true;
}

void DocHeal(Critter&cr)
{
	if(!(@cr!=null))return;
	
	DropBleed(cr);
	DropToxic(cr);
	cr.StatBase[(146)]=0;
	cr.EraseTimeEvents((41));
	cr.EraseTimeEvents((42));
	
	for(uint16 i=502;i<506;++i)
	{
		if(cr.ParamBase[i]!=0)Prolonged_Doc(cr,Random(500,1000),i);
	}
	
	Prolonged_heal(cr,300);
}            

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                        

void LightInit(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_LightSkill");        
	
	string picName="art\\scenery\\whitePXL.frm";
	
	uint hash=GetStrHash(picName);
	item.SetMapPic(hash);
	
	item.LightColor=9999666;
	item.LightDistance=6;
	
	item.LightIntensity=(item.Val1>1?0:100);
	
	item.Update();
	
}

bool _LightSkill(Item&item,Critter&cr,int skill)
{
	return true;
}  

void ObjectTimeLoop()
{
	
	GameVar@Phoenixpower=GetGlobalVar((9997));
	GameVar@power=GetGlobalVar((9996));
	
	if(Random(0,23)==0)
	{
		if(Phoenixpower.GetValue()>0)Phoenixpower.opSub(1);
		if(power.GetValue()>0)power.opSub(1);
	}
	
	for(uint8 i=0;i<mapPids.length();++i)
	{
		Map@map=GetMapByPid(mapPids[i],0);
		if(map is null)
		continue;
		
		Item@[]water;
		Item@[]air;
		
		map.GetItems((1300),water);
		map.GetItems((1302),air);
		uint8 airLen=air.length();
		uint8 airMod=100/(airLen>0?airLen:1);
		uint8 airPer=0;
		
		for(uint8 ii=0,jj=air.length();ii<jj;++ii)
		{
			Item@item=air[ii];
			
			if(item is null)
			continue;
			
			uint8 switcher=item.Val2;
			
			if(switcher>0)
			{
				airPer+=airMod;
			}
		}
		
		GameVar@dyspnea=GetLocalVar((9990),map.Id);
		if(!(dyspnea is null))
		{
			if(airPer<70)
			{
				dyspnea.opAddAssign(25);
				map.SetData((25),1);
			}
			else
			{
				dyspnea.opSub(20);
				map.SetData((25),0);
			}
		}
		
		for(uint8 ii=0,jj=water.length();ii<jj;++ii)
		{
			Item@item=water[ii];
			
			if(item is null)
			continue;
			
			uint8 switcher=item.Val2;
			uint8 water=item.Val3;
			
			if(power.GetValue()>0)
			{
				water++;
				water=(((water)>(100))?(100):(((water)<(0))?(0):(water)));
				item.Val3=water;
			}
		}
	}
	
	for(uint8 i=0;i<Phoenix_mapPids.length();++i)
	{
		Map@map=GetMapByPid(Phoenix_mapPids[i],0);
		if(map is null)
		continue;
		
		Item@[]water;
		
		map.GetItems((1300),water);
		
		for(uint8 ii=0,jj=water.length();ii<jj;++ii)
		{
			Item@item=water[ii];
			
			if(item is null)
			continue;
			
			uint8 switcher=item.Val2;
			uint8 water=item.Val3;
			
			if(Phoenixpower.GetValue()>0)
			{
				water++;
				water=(((water)>(100))?(100):(((water)<(0))?(0):(water)));
				item.Val3=water;
			}
		}
	}
}

void ProccessAir(){}

void ShowLight(Critter&cr,int x,int,int)
{
	Item@[]item;
	Map@map=cr.GetMap();
	
	if(map is null)
	return;
	
	map.GetItems((1305),item);
	
	for(uint16 i=0,j=item.length();i<j;++i)
	{
		string picName="art\\scenery\\";
		
		if(x>0)
		{
			picName+="grid_wall.frm";
		}
		else
		{
			picName+="whitePXL.frm";
		}
		
		uint hash=GetStrHash(picName);
		item[i].SetMapPic(hash);
		
		cr.Say((11),"flag "+item[i].Flags);
	}
	
}                  

void debugOnOff(Critter&cr,int val,int,int){
	Map@map=cr.GetMap();
	
	if(map is null)return;
	
	Item@[]items;
	map.GetItems((1303),items);
	
	for(uint8 i=0,j=items.length();i<j;++i){
		items[i].Val1=1;
		if(items[i].Val3<=0){
			items[i].Val3=4;
		}
	}
	
	for(uint8 i=0;i<mapPids.length();++i)
	{
		Map@map=GetMapByPid(mapPids[i],0);
		if(map is null)
		continue;
		
		map.SetData((24),val);
		
		Item@[]water;
		Item@[]air;
		Item@[]doc;
		Item@[]door;
		
		map.GetItems((1300),water);
		map.GetItems((1302),air);
		map.GetItems((1304),doc);
		
		map.GetItemsByType((9),door);
		
		for(uint8 ii=0,jj=water.length();ii<jj;++ii)
		{
			Item@item=water[ii];
			
			if(item is null)
			continue;
			
			item.Val1=val;
			item.Val2=val;
			
		}
		
		for(uint8 ii=0,jj=air.length();ii<jj;++ii)
		{
			Item@item=air[ii];
			
			if(item is null)
			continue;     
			
			item.Val1=val;
			item.Val2=val;
		}
		
		for(uint8 ii=0,jj=doc.length();ii<jj;++ii)
		{
			Item@item=doc[ii];
			
			if(item is null)
			continue;     
			
			item.Val1=val;
			item.Val2=val;
			
		}
		
		for(uint8 ii=0,jj=door.length();ii<jj;++ii)
		{
			Item@item=door[ii];
			
			if(item is null)
			continue;
			
			if(IsDoorAutomatic(item.GetProtoId()))
			{
				item.Val6=val;
			}
		}
		
	}
	
	for(uint8 i=0,j=mapLight.length();i<j;++i)
	{
		Map@map=GetMapByPid(mapLight[i],0);
		if(map is null)
		continue;
		
		Item@[]light;
		
		map.GetItems((1305),light);
		
		for(uint8 ii=0,jj=light.length();ii<jj;++ii)
		{
			Item@item=light[ii];
			
			if(item is null)
			continue;  
			
			item.Val1=val;
			
			item.LightIntensity=(val>0?100:0);
			
			item.Update();
		}
	} 
	
}

void spawn_autodoors(Critter&cr,int val,int,int)
{
	for(uint8 i=0;i<ALLamapPids.length();++i)
	{
		Map@map=GetMapByPid(ALLamapPids[i],0);
		if(map is null)
		continue;
		
		Item@[]door;
		
		map.GetItemsByType((9),door);
		
		for(uint8 ii=0,jj=door.length();ii<jj;++ii)
		{
			Item@item=door[ii];
			
			if(item is null)
			continue;
			
			if(IsDoorAutomatic(item.GetProtoId()))
			{
				uint16 x=item.HexX;
				uint16 y=item.HexY;
				for(uint8 i=0;i<6;i++)
				{
					map.MoveHexByDir(x,y,i,1);
					if(!(@map.GetItem(x,y,(1544))!=null))
					{
						Item@pedal=map.AddItem(x,y,(1544),1);
						pedal.Val1=item.Id;
					}
					x=item.HexX;
					y=item.HexY;
				}
				
			}
		}
		
	}
} 

void debugDyspnea(Critter&cr,int val,int,int){
	Map@map=cr.GetMap();
	if(map is null)return;
	
	GameVar@dyspnea=GetLocalVar((9990),map.Id);
	if(dyspnea is null)return;
	
	dyspnea.opAssign((((val)>(100))?(100):(((val)<(0))?(0):(val))));
	map.SetData((25),(((val)>(1))?(1):(((val)<(0))?(0):(val)))); 
	
	return;
}

bool check_parts(Item&item,Critter&cr,Item@usedItem)
{
	if(item is null||usedItem is null)
	return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(item.Val6>0){cr.Say((11),"Пока еще непонятно в чем проблема.");return false;}
	if(item.Val4>0)
	{
		if(pid==item.Val4)
		{
			cr.Say((11),"Вы установили требуемую деталь.");
			do{if(usedItem.GetCount()>(1))
				usedItem.SetCount(usedItem.GetCount()-(1));else
				DeleteItem(usedItem);}while(false);
			item.Val4=0;
			return true;
		}
		cr.Say((11),"Деталь не подходит.");
		return false;
	}
	return true;
}

bool check_repair(Item&item,Critter&cr)
{
	if(item is null)
	return false;
	
	if(item.Val6>0){cr.Say((11),"Пока еще непонятно в чем проблема.");return false;}
	if(item.Val4>0){cr.Say((11),"Пока еще нет нужной детали.");return false;}
	if(cr.Skill[(213)]<item.Val5){cr.Say((11),"Недостаточно навыка для того чтобы исправить проблему.");return false;}
	else
	{
		cr.Say((11),"Вы определили неисправность и устранили ее.");
		item.Val5=0;
	}
	return true;
}

bool check_science(Item&item,Critter&cr)
{
	if(item is null)
	return false;
	
	uint16 science=item.Val6;
	uint16 parts=item.Val4;
	if(science>0)
	{
		if(cr.Skill[(212)]<science){cr.Say((11),"Недостаточно навыка для того чтобы определить проблему.");return false;}
		else
		{
			if(parts>0){cr.Say((11),"Вы определили и пометили неисправность, требуется деталь:");cr.SayMsg((11),(2),parts*100);}
			else if(item.Val5>0)cr.Say((11),"Вы определили и пометили неисправность, остается применить практические навыки.");
			else cr.Say((11),"Вы определили неисправность и устранили ее.");
			item.Val6=0;
			return true;
		}
	}
	return true;
}