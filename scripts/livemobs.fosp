                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

bool AddMiscPlane(Critter&npc,uint priority,uint waitSecond,string@funcName)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(0);
	plane.Priority=(priority==0?(10):priority);
	plane.Misc_WaitSecond=waitSecond;
	if((@funcName!=null)&&not plane.Misc_SetScript(funcName))
	{
		Log("Set script <"+funcName+"> fail");
		return false;
	}
	return npc.AddPlane(plane);
}

bool AddWalkPlane(Critter&npc,uint entire,uint cut,bool run)
{
	uint16 hX=0,hY=0;
	Map@map=npc.GetMap();
	if((@map!=null)&&map.GetEntireCoords(entire,0,hX,hY))
	{
		return AddWalkPlane(npc,0,hX,hY,6,run,cut);
	}
	return false;
}

bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)
{
	if(not npc.IsCanWalk())
	return false;
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(2);
	plane.Priority=(priority==0?(20):priority);
	plane.Walk_HexX=hexX;
	plane.Walk_HexY=hexY;
	plane.Walk_Dir=dir;
	plane.Run=run;
	plane.Walk_Cut=cut;
	return npc.AddPlane(plane);
}

bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)
{
	if(not npc.IsCanWalk())
	return false;
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(2);
	plane.Priority=(priority==0?(20):priority);
	plane.Identifier=identifier;
	plane.IdentifierExt=identifierExt;
	plane.Walk_HexX=hexX;
	plane.Walk_HexY=hexY;
	plane.Walk_Dir=dir;
	plane.Run=run;
	plane.Walk_Cut=cut;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexY=target.HexY;
	plane.Attack_LastHexX=target.HexX;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,bool run)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp,bool run)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp,bool run)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddPickPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint16 protoId,uint useItemId,bool toOpen)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(3);
	plane.Priority=(priority==0?(35):priority);
	plane.Pick_HexX=hexX;
	plane.Pick_HexY=hexY;
	plane.Pick_Pid=protoId;
	plane.Pick_UseItemId=useItemId;
	plane.Pick_ToOpen=toOpen;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(3);
	plane.Priority=(priority==0?(35):priority);
	plane.Pick_HexX=item.HexX;
	plane.Pick_HexY=item.HexY;
	plane.Pick_Pid=item.GetProtoId();
	plane.Pick_UseItemId=useItemId;
	plane.Pick_ToOpen=toOpen;
	plane.Run=false;
	return npc.AddPlane(plane);
}

uint EraseAttackPlane(Critter&npc,Critter&target)
{
	return EraseAttackPlane(npc,target.Id);
}

uint EraseAttackPlane(Critter&npc,uint critId)
{
	NpcPlane@[]planes;
	uint count=npc.GetPlanes(planes);
	if(count==0)
	return 0;
	
	uint erased=0;
	for(uint i=0;i<count;i++)
	{
		if(planes[i].Attack_TargId==critId&&npc.ErasePlane(i-erased))
		erased++;
	}
	
	return erased;
}     

void SetCheckPointPath(Item&item,uint8 index,uint16 value)
{
	if(index>=0&&index<4)
	switch(index)
	{
		case 0:
		item.Val0=value;
		break;
		case 1:
		item.Val1=value;
		break;
		case 2:
		item.Val2=value;
		break;
		case 3:
		item.Val3=value;
		break;
		
		default:
		break;
	}
}

void SetCheckPointCritters(Item&item,uint8 index,uint16 critterGroup)
{
	if(index>=0&&index<4)
	{
		uint16 path0=(item.Val4)&0xFFFF,
		path1=(item.Val4>>16)&0xFFFF,
		path2=(item.Val5)&0xFFFF,
		path3=(item.Val5>>16)&0xFFFF,
		pathTemp=0;
		
		switch(index)
		{
			case 0:
			!(((path0)&(critterGroup))!=0)?(path0=(path0)|(critterGroup)):(path0=((path0)&(~(critterGroup))));
			break;
			case 1:
			!(((path1)&(critterGroup))!=0)?(path1=(path1)|(critterGroup)):(path1=((path1)&(~(critterGroup))));
			break;
			case 2:
			!(((path2)&(critterGroup))!=0)?(path2=(path2)|(critterGroup)):(path2=((path2)&(~(critterGroup))));
			break;
			case 3:
			!(((path3)&(critterGroup))!=0)?(path3=(path3)|(critterGroup)):(path3=((path3)&(~(critterGroup))));
			break;
			default:
			break;
		}
		
		item.Val4=((path0)&0xFFFF)|((path1<<16)&0xFFFF);
		item.Val5=((path2)&0xFFFF)|((path3<<16)&0xFFFF);
	}
}

bool CheckCritterTypeCheckPoint(Item&item,uint8 index,uint16 critterGroup)
{
	if(index>=0&&index<4)
	{
		uint16 path0=(item.Val4)&0xFFFF,
		path1=(item.Val4>>16)&0xFFFF,
		path2=(item.Val5)&0xFFFF,
		path3=(item.Val5>>16)&0xFFFF,
		pathTemp=0;
		
		switch(index)
		{
			case 0:
			pathTemp=path0;
			break;
			case 1:
			pathTemp=path1;
			break;
			case 2:
			pathTemp=path2;
			break;
			case 3:
			pathTemp=path3;
			break;
			default:
			return false;
		}
		
		if((((pathTemp)&(critterGroup))!=0)||pathTemp==0)
		return true;
		
	}
	
	return false;
}

Item@FindNearesCheckPoint(Critter&cr)
{
	uint16 hexX=0,hexY=0;
	
	Item@checkpoint;
	Item@[]@points;
	Map@map=cr.GetMap();
	
	if(map is null)
	{
		cr.Say((1),"map is null");
		return null;
	}
	
	cr.Say((1),""+map.GetItems((3),points));
	
	if(points[0]is null)
	{
		cr.Say((1),"points is null");
		return null;
	}
	
	for(uint16 i=0;i<points.length();++i)
	{
		if(points[i]!is null)
		{
			int hexXTemp=(((points[i].HexX-cr.HexX)>0)?(points[i].HexX-cr.HexX):-(points[i].HexX-cr.HexX)),hexYTemp=(((points[i].HexY-cr.HexY)>0)?(points[i].HexY-cr.HexY):-(points[i].HexY-cr.HexY));
			if((hexX<hexXTemp&&hexY<hexYTemp)&&CheckCritterTypeCheckPoint(points[i],cr.StatBase[(98)],cr.StatBase[(99)]))
			{
				hexX=hexXTemp;
				hexY=hexYTemp;
				
				@checkpoint=points[i];
			}
		}
	}   
	
	return null;
}  

void AddCheckPoint(Critter&cr,int index,int hexX,int hexY)
{
	Item@item=cr.GetMap().AddItem((hexX>0?hexX:cr.HexX),(hexY>0?hexY:cr.HexY),(3),1);
	if(item!is null)
	{
		SetCheckPointPath(item,index,cr.StatBase[(98)]);
		cr.StatBase[(98)]=item.Id;
	}
}

void EditLastCheckPoint(Critter&cr,int type,int index,int value)
{
	Item@item=GetItem(cr.StatBase[(90)]);
	if(item!is null)
	{
		if(type>0)
		SetCheckPointCritters(item,index,value);
		else
		SetCheckPointPath(item,index,value);
	}
}      

void _LeaderInit(Critter&npc,bool firstTime)
{
	npc.SetEvent((0),"_Patrol");
}

void _Patrol(Critter&npc)
{
	Item@item=FindNearesCheckPoint(npc);
	if(item!is null)
	{
		SetCritterMove(npc,item.HexX,item.HexY);
	}
}

void SetCritterMove(Critter&leader,uint16 hexX,uint16 hexY)
{
	GameVar@minionId;
	
	for(uint8 i=0;i<(5);++i)
	{
		@minionId=GetLocalVar(((11000))+i,leader.Id);
		Critter@minion=GetCritter(minionId.GetValue());
		if(minion!is null)
		{
			AddWalkPlane(minion,10,hexX,hexY,Random(0,5),false,0);
		}
	}
}

void SetLeaderMinion(Critter&leader,Critter&minion)
{
	GameVar@minionId;
	
	for(uint8 i=0;i<(5);++i)
	{
		@minionId=GetLocalVar(((11000))+i,leader.Id);
		if(minionId.GetValue()==0&&minionId.GetValue()!=minion.Id)
		{
			minionId=minion.Id;
		}
	}
}  

void test(Critter&cr,int pointsCount,int mobCout,int radius)
{
	for(uint8 i=0;i<pointsCount;++i)
	{
		uint16 hexX=cr.HexX+Random(radius-(radius*radius),radius),hexY=cr.HexY+Random(radius-(radius*radius),radius);
		
		AddCheckPoint(cr,0,hexX,hexY);
		
		Critter@leader=cr.GetMap().AddNpc(64,hexX+Random(0,4),hexY+Random(0,4),Random(0,5),null,null,null);
		if(leader is null)
		{
			cr.Say((1),"null leader");
			continue;
		}
		leader.SetScript("livemobs@_LeaderInit");
		for(uint8 i=0;i<(5);++i)
		{
			Critter@minion=cr.GetMap().AddNpc(63,hexX+Random(0,4),hexY+Random(0,4),Random(0,5),null,null,null);
			SetLeaderMinion(leader,minion);
		}
	}
}

void test1(Critter&cr,int pointsCount,int mobCout,int radius)
{
	for(uint8 i=0;i<pointsCount;++i)
	{
		uint16 hexX=cr.HexX+Random(radius-(radius*radius),radius),hexY=cr.HexY+Random(radius-(radius*radius),radius);
		
		AddCheckPoint(cr,0,hexX,hexY);
	}
}

void test2(Critter&cr,int pointsCount,int mobCout,int radius)
{
	Item@item=FindNearesCheckPoint(cr);
}
