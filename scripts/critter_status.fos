// critter status
// pm

#include "_macros.fos"

import int  GetDeteriorationProcent( Item& item ) from "repair";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat"; // Export

void ChangeStatus( Critter& cr, uint16 status, uint8 value, bool set )                                      // export
{
    bool onlyFlag = false;

    if( set )
    {
        switch( status )
        {
        case CR_STATUS_BLEED:
            BleedCritter( cr, value );
            break;
        case CR_STATUS_BLOOD_TOXIC:
            BloodToxicCritter( cr );
            break;
        default:
            break;
        }

        SETFLAG( cr.StatBase[ ST_CRSTATUS ], status );
    }
    else
    {
        switch( status )
        {
        case CR_STATUS_HEAVY_DMG:
            onlyFlag = true;
            break;
        case CR_STATUS_BULLET_OVER:
            onlyFlag = true;
            break;
        default:
            break;
        }

        if( onlyFlag && FLAG( cr.StatBase[ ST_CRSTATUS ], status ) )
            UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], status );
    }
}

void BleedCritter( Critter& cr, int8 bleedValue )
{
    //Находим все активные ивенты, отслеживающие кровотечения и дропаем их, стартуя новый:
	uint[] indexes, durations, rates;
    int eventCount = cr.GetTimeEvents( CTE_BLEED, indexes, durations, rates );
	if( eventCount > 0 ) cr.EraseTimeEvents( CTE_BLEED );
    cr.AddTimeEvent( "cte_bleed", REAL_SECOND( 60 ), CTE_BLEED, 0 ); //Обновление таймера позволяет не откинуться от кровотечения посреди боя.
	cr.StatBase[ ST_BLEED ] += bleedValue;
}

uint[][] bloods = { { PID_BLOOD_SMALL_1, PID_BLOOD_SMALL_2, PID_BLOOD_SMALL_3 }, { PID_BLOOD_BIG_1, PID_BLOOD_BIG_2, PID_BLOOD_BIG_3 } };
uint spoil_Val = 3;

uint cte_bleed( Critter& cr, int identifier, uint& rate )
{
	int maxHP = cr.Stat [ST_MAX_LIFE];

	//Нанесение урона от кровопотери:
    int bleed = CLAMP( cr.StatBase[ ST_BLEED ] * 0.9 - 1, 0, maxHP ); //Падает на [10% + 1]
	cr.StatBase[ ST_BLEED ] = bleed;
    
    cr.StatBase[ ST_CURRENT_HP ] -= bleed / 2;
    cr.ParamBase[ BP_BLOOD_LOSS ] += bleed / 2;

    if( cr.ParamBase [BP_BLOOD_LOSS] > maxHP * 0.75 )
		cr.Say( SAY_NETMSG, "Вы чувствуете слабость от обильной кровопотери." );
	
	if( cr.ParamBase [BP_BLOOD_LOSS] > maxHP - __DeadHitPoints ) //Смертельная кровопотеря. 
    { //Пока что является конечной точкой для логики вытекания, хотя на деле ИРЛ тело ещё доооолго может кровоточить после преодоления "смертельного" рубежа кровопотери.
		//Защита от "излишней" кровопотери, приводящей к невозможности реснуть и поднять на ноги умершего от неё.
    	cr.ParamBase [BP_BLOOD_LOSS] = maxHP; 
        UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLEED );
		cr.StatBase[ ST_BLEED ] = 0;

		//Падение обессиленного:
		uint anim2Dead = Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_PRONE_BACK;
    	if( cr.IsKnockout() ) {
            if(cr.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT)
                anim2Dead = ANIM2_DEAD_PRONE_FRONT;
            else
                anim2Dead = ANIM2_DEAD_PRONE_BACK;
        } 
        cr.ToDead (anim2Dead, cr);
		
		cr.Say( SAY_NETMSG, "Силы покидают вас, вы начинаете медленно умирать от потери большого количества крови.");
        return 0;
    }
    
	//Кровь вытекает под существо:
	uint16 hx = cr.HexX, hy = cr.HexY;
	Map@ map = cr.GetMap();
	Item@ blood; 
	if( valid(map) )
	{
		//Ищем уже имеющуюся кровь под существом:
		Item@[] dirt;
		map.GetItems( hx, hy, dirt );
		bool wasBlooded = false;
		for( uint i = 0; i < dirt.length(); i ++ )
		{
			uint itempid = dirt[i].GetProtoId();
			if( bloods[0].find( itempid ) != -1 ) //Если это малая лужа - увеличиваем её.
			{
				dirt[i].Val0++;
				if( dirt[i].Val0 >= spoil_Val )
					dirt[i].ChangeProto( bloods[1][Random( 0, bloods[1].length() )] );
				wasBlooded = true;
				break;
			}
			if( bloods[1].find( itempid ) != -1 ) //Если это большая лужа - просто "усиливаем" её.
			{
				dirt[i].Val0++;
				wasBlooded = true;
				break;
			}
		}
		if( !wasBlooded )
			@blood = map.AddItem( hx, hy, bloods[0][Random( 0, bloods[0].length() )], 1 );
	}
	if( valid(blood) )
	{
		uint[] values = { blood.Id };
		blood.Val1 = CreateTimeEvent( __FullSecond + REAL_MINUTE( 15 * blood.Val0 ), "e_dryup", values, false );
	}
	return REAL_SECOND( 30 );
}

uint e_dryup( uint[]@ values )
{
	if( !valid(values) ) return 0;
	
	Item@ blood = GetItem( values[0] );
	if( !valid(blood) ) return 0;
	
	DeleteItem(blood);
	return 0;
}

void DropBleed( Critter& cr )
{
    uint[] indexes;
    uint[] rates;
    uint[] durations;
    uint8 eventCount = cr.GetTimeEvents( CTE_BLEED, indexes, durations, rates );

    if( eventCount > 0 )
        cr.EraseTimeEvents (CTE_BLEED);
}

void BloodToxicCritter( Critter& cr )
{
    if( cr.GetTimeEvents( CTE_BLOOD_TOXIC, null, null, null ) > 0 )
	{
	    cr.StatBase[ ST_BLOOD_TOXIC ] ++;
	}
	//else if( ST_BLOOD_TOXIC >= 0 ) cr.AddTimeEvent( "cte_org_dmg",  10 * __TimeMultiplier , CTE_ORG_DMG, 0 );
    else cr.AddTimeEvent( "cte_blood_toxic",  10 * __TimeMultiplier , CTE_BLOOD_TOXIC, 0 );
}

uint cte_blood_toxic( Critter& cr, int identifier, uint& rate )
{
    uint8 toxicLevel = cr.StatBase[ ST_BLOOD_TOXIC ];
	if( cr.StatBase[ ST_BODY_TYPE ] == BT_ROBOT )
    {
        UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLOOD_TOXIC );
		cr.StatBase[ ST_BLOOD_TOXIC ] = 0;
        cr.Say( SAY_NETMSG, "Роботы не страдают от заражения крови, ведь у них ее нет!" );
        return 0;
    }
    if( toxicLevel >= cr.Stat[ ST_ENDURANCE ] * 20 )
    {
        cr.ToDead( Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null );
        UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLOOD_TOXIC );
	cr.StatBase[ ST_BLOOD_TOXIC ] = 0;
        cr.Say( SAY_NETMSG, "Вы умерли от заражения крови." );
        return 0;
    }
    else if( toxicLevel <= 0 )
        return 0;

    cr.StatBase[ ST_BLOOD_TOXIC ] ++;
    cr.Say( SAY_NETMSG, "Вы страдаете от заражения крови. /используйте таблетки через навык доктора, дабы спасти себя/");
    return ( 60 * 5 * __TimeMultiplier );
}

void DropToxic( Critter& cr )
{
    uint[] indexes;
    uint[] rates;
    uint[] durations;
    uint8 eventCount = cr.GetTimeEvents( CTE_BLOOD_TOXIC, indexes, durations, rates );

    if( eventCount > 0 )
    {
        cr.EraseTimeEvent( indexes[ 0 ] );
    }

    cr.StatBase[ ST_BLOOD_TOXIC ] = 0;
}

//#####################################################################################
/*void OrgDmgCritter( Critter& cr )
{
    if( cr.StatBase[ ST_ORG_DMG ] >= 1 )
	{
	    cr.StatBase[ ST_ORG_DMG ] ++;
		cr.AddTimeEvent( "cte_org_dmg",  10 * __TimeMultiplier , CTE_ORG_DMG, 0 );
	}
    else cr.AddTimeEvent( "cte_org_dmg",  10 * __TimeMultiplier , CTE_ORG_DMG, 0 );
}

uint cte_org_dmg( Critter& cr, int identifier, uint& rate )
{
    uint8 orgDmg = cr.StatBase[ ST_ORG_DMG ];
    if( orgDmg >= cr.Stat[ ST_ENDURANCE ] * 90 )
    {
        cr.ToDead( Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null );
        UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_ORG_DMG );
	cr.StatBase[ ST_ORG_DMG ] = 0;
        cr.Say( SAY_NETMSG, "У вас отказал жизненно важный орган" );
        return 0;
    }
    else if( orgDmg <= 0 )
        return 0;

    cr.StatBase[ ST_ORG_DMG ] ++;
    cr.Say( SAY_NETMSG, "Жуткая боль пронзает все ваше тело. /используйте таблетки через навык доктора, дабы спасти себя/");
    return ( 60 * 1 * __TimeMultiplier );
}*/
