      

funcdef uint PROCESS(Critter@,int&,int&,int&);                  

import bool RegisterProcess(uint8 type,any func)from"ltp";

import bool StartProcess(Critter&cr,uint8 type,int param0,int param1,int param2,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,int param0,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,uint time)from"ltp";

import bool StopProcess(Critter&cr)from"ltp";

import bool checkTDH(Critter&cr)from"ltp";
import bool checkTDH(Critter&cr,uint8 type)from"ltp";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";

void _InitSnowBallBag(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_SnowBallBagSkill");
}

bool e_SnowBallBagSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		
		if(cr.ItemsWeight()+GetProtoItem((1429)).Weight>cr.Stat[(11)])
		{
			cr.Say((11),"Вы не можете взять больше вещей.");
			return true;
		}
		uint8 time=11-(cr.Stat[(5)]);
		if(!ltp_snow_inited)
		ltp_snow_init();
		StartProcess(cr,(33),0,0,0,time*1000);
		return true;
	}
	return false;
}

bool s_SnowBallBag(Critter&cr,Scenery&scen,int skill,Item@item)
{
	if(skill==(-1))
	{
		
		if(cr.ItemsWeight()+GetProtoItem((1429)).Weight>cr.Stat[(11)])
		{
			cr.Say((11),"Вы не можете взять больше вещей.");
			return true;
		}
		uint8 time=17-(cr.Stat[(5)]*1.6);
		if(!ltp_snow_inited)
		ltp_snow_init();
		StartProcess(cr,(33),0,0,0,time*1000);
		cr.Say((11),"Вы лепите снежок");
		return true;
	}
	return false;
}

bool ltp_snow_inited=false;

void ltp_snow_init()
{
	PROCESS@___pfunc=@process_snow;any ___pany;___pany.store(@___pfunc);RegisterProcess((33),___pany);
	ltp_snow_inited=true;
}

uint process_snow(Critter@cr,int&param0,int&param1,int&param2)
{
	if(param0==-1&&(cr is null)){param0=int((33));return(0xF035BCF3);}
	
	Item@snowBall=cr.GetItem((1429),-1);
	if(@snowBall!=null)
	{
		snowBall.SetCount(snowBall.GetCount()+1);
		return 0;
	}
	else
	{
		@snowBall=cr.AddItem((1429),1);     
		
	}
	return 0;
}

void _InitSnowBall(Item&item,bool firstTime)
{
	item.SetEvent((1),"e_SnowBallAttack");
}

bool e_SnowBallAttack(Item&item,Critter&cr,Critter&target)
{
	
	InjureCritter(target,1,1,target.Dir,cr.Id);
	bool roll=((cr.Stat[(0)]*10)+(cr.Skill[(205)]/5)>(target.Stat[(5)]*6)+(target.Stat[(2)]*6)+(target.Stat[(6)]*6)+Random(0,70));
	if(roll)
	{
		target.ToKnockout(((Random(0,1)==0?true:false)?(82):(83)),((Random(0,1)==0?true:false)?(86):(87)),((Random(0,1)==0?true:false)?(88):(89)),Random(4,20),target.HexX,target.HexY);
		target.Action((16),0,null);
	}
	cr.Action((6),0,null);
	if(item.GetCount()>1)
	{
		item.SetCount(item.GetCount()-1);
		item.Update();
	}
	else
	{
		DeleteItem(item);
	}
	return true;
}

bool s_TreeTreasure(Critter&cr,Scenery&scen,int skill,Item@item)
{
	GameVar@qTree=GetLocalVar((34),cr.Id);
	if(@item==null||@qTree==null||item.GetProtoId()!=(1448))
	return false;
	
	uint8 qCount=qTree.GetValue();
	
	if(qCount==0)
	{
		cr.Say((11),"Вы украсили елку.");
	}
	else
	{
		string msg;
		for(uint8 i=2;i<qCount;i++)
		{
			msg+=" и снова";
		}
		cr.Say((11),"Вы уже вешали игрушку, темнимение ничего не мешает сделать это снова"+msg);
	}
	
	qTree=qCount+1;
	if(item.GetCount()>1)
	{
		item.SetCount(item.GetCount()-1);
		item.Update();
	}
	else
	{
		DeleteItem(item);
	}
	
	return true;
}

void _InitTreeMap(Map&map,bool firstTime)
{
	map.SetEvent((6),"e_CritterIn");
	map.SetEvent((6),"e_CritterOut");
}

void e_CritterIn(Map&map,Critter&cr)
{
	cr.SetEvent((15),"e_CritterAttack");
}

void e_CritterOut(Map&map,Critter&cr)
{
	cr.SetEvent((15),"");
}

bool e_CritterAttack(Critter&cr,Critter&target)
{
	return true;
}    

bool d_TreeCheck(Critter&master,Critter&slave)
{
	GameVar@qTree=GetLocalVar((34),master.Id);
	if(qTree!=null&&qTree.GetValue()==0)
	{
		return true;
	}
	return false;
}
