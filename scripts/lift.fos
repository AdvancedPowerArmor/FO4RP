#include "_macros.fos"

#define PID_LIFT_1 2000
#define PID_LIFT_2 3605
#define FOTEXT_LIFT    # (__FOTEXT_LIFT_group, __FOTEXT_LIFT_floor)   ( 20000 + ( __FOTEXT_LIFT_group )*100 + ( __FOTEXT_LIFT_floor ) )

bool lifts_initialized = false;
uint[][] lifts_ids;

uint[][] lifts_hexes = {
    {PID_LIFT_1, 0, 1}
};

void _LiftInit( Item& item, bool firstTime ) {
    //item.SetEvent( ITEM_EVENT_WALK, "e_LiftWalk" );
    SETFLAG(item.Flags, ITEM_CAN_USE);
    item.SetEvent( ITEM_EVENT_SKILL, "e_LiftSkill" );
    CreateTimeEvent( __FullSecond + REAL_SECOND(3), "e_LiftAutoInit", item.Id, false );
}

uint e_LiftAutoInit( uint[] @ val ) {
    if( !lifts_initialized ) {
        InitializeLifts();
    }
    return 0;
}

void resetLifts( Critter& cr, int p1, int p2, int param2 ) {
    lifts_initialized = false;
    InitializeLifts();
}

uint[]@ GetLiftHexes(uint16 pid) {
    for(uint i=0, len=lifts_hexes.length(); i<len; i++) {
        uint[]@ hexes = lifts_hexes[i];
        uint hexes_length = hexes.length();
        if(hexes_length == 0 || hexes[0] != pid) {
            continue;
        }
        if(hexes_length < 3 || hexes_length%2==0) {
            return null;
        }
        return hexes;
    }
    return null;
}

uint GetLift(uint group, uint floor) {
    if (lifts_ids.length() < group) {
        return 0;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (group_ids.length() < floor) {
        return 0;
    }
    return group_ids[floor];
}

uint GetGroupType(uint group) {
    if (lifts_ids.length() < group) {
        return 0;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (group_ids.length() == 0) {
        return 0;
    }
    return group_ids[0];
}

void SetLift(uint group, uint floor, uint value, uint pid) {
    if (lifts_ids.length() < group) {
        lifts_ids.resize(group);
    }
    uint[]@ group_ids = lifts_ids[group-1];
    uint group_ids_len = group_ids.length();
    if (group_ids.length() <= floor) {
        group_ids.resize(floor+1);
        for(uint i=MAX(group_ids_len, 1); i<floor; ++i) {
            group_ids[i] = 0;
        }
        group_ids[0] = pid;
    }
    group_ids[floor] = value;
}

bool IsSettingsValid(uint group, uint floor) {
    if( group == 0 || group > 99 ) {
        Log("Invalid lifts' group: "+group);
        return false;
    }
    if( floor == 0 || floor > 99 ) {
        Log("Invalid lifts' floor: "+floor);
        return false;
    }
    return true;
}

uint InitializeLiftsFor(uint16 pid) {
    Item@[] items;
    uint _count = GetAllItems (pid, items);
    uint count_ok = 0;

    for(uint i=0, l=items.length(); i<l; ++i) {
        Item@ item = items[i];
        uint group = item.Val1;
        uint floor = item.Val2;
        if (!IsSettingsValid(group, floor)) {
            continue;
        }
        uint group_type = GetGroupType(group);
        if (group_type != 0 && group_type != pid) {
            LiftDebug("Different prototypes of lifts in the same group: "+pid+" != "+group_type, item);
            continue;
        }
        uint prev_lift = GetLift(group, floor);
        if( prev_lift != 0 ) {
            LiftDebug("Collision of lifts' settings, previous value: "+prev_lift, item);
            continue;
        }
        SetLift(group, floor, item.Id, pid);
        count_ok += 1;
    }
    return count_ok;
}

void InitializeLifts() {
    lifts_initialized = true;
    lifts_ids.resize(0);
    uint count_ok = 0;
    count_ok += InitializeLiftsFor(PID_LIFT_1);
    count_ok += InitializeLiftsFor(PID_LIFT_2);
    Log("Lifts initialized: "+count_ok);
}

void LiftDebug(string@& message, Item& item) {
    uint16 hexX = 0, hexY = 0;
    Map@ map = item.GetMapPosition (hexX, hexY);
    if(map is null) {
        Log(message+"; item.Id: "+item.Id+", group: "+item.Val1+", floor: "+item.Val2+", map is null");
    } else {
        Log(message+"; item.Id: "+item.Id+", group: "+item.Val1+", floor: "+item.Val2+
            ", map.Id: "+map.Id+", hexX: "+hexX+", hexY: "+hexY);
    }    
}

bool e_LiftSkill( Item& item, Critter& cr, int skill ) {
    if( skill == SKILL_PICK_ON_GROUND ) {
        LiftActivate(item, cr);
        return true;
    }
    return false;
}

void e_LiftWalk( Item& item, Critter& cr, bool entered, uint8 dir ) {
    if( entered ) {
        LiftActivate(item, cr);
    }
}

void LiftActivate(Item& item, Critter& cr) {
    if( !lifts_initialized ) {
        InitializeLifts();
    }

    if (cr.IsNpc()) {
        //npc can't ride on lift
        return;
    }
    uint16 item_hexX = 0, item_hexY = 0;
    Map@ item_map = item.GetMapPosition (item_hexX, item_hexY);
    if (item_map is null) {
        LiftDebug("Player "+cr.Id+" is activating lift which is not on the map", item);
        return;
    }

    Map@ map = cr.GetMap();
    if (map is null) {
        LiftDebug("Player "+cr.Id+" is activating lift while on global", item);
        return;
    }

    if (item_map.Id != map.Id) {
        LiftDebug("Player "+cr.Id+" is activating lift which is on the other map", item);
        return;
    }

    uint group = item.Val1;
    uint floor = item.Val2;
    cr.Say(SAY_NETMSG, "group: "+group+", floor: "+floor);
    if (!IsSettingsValid(group, floor)) {
        return;
    }
    uint lift_id = GetLift(group, floor);
    if (lift_id == 0 || lift_id != item.Id) {
        LiftDebug("Player is activating lift that's not registered correctly", item);
        return;
    }
/*
    if (item_hexX != cr.HexX || item_hexY != cr.HexY-1) {
        cr.Say(SAY_NETMSG, "Перед тем, как воспользоваться лифтом - нужно в него зайти.");
        return;
    }
*/
    uint[]@ group_ids = lifts_ids[group-1];
    uint floors_in_group = group_ids.length()-1;

    cr.ShowScreen( SCREEN_DIALOGBOX, floors_in_group-1, "answer_LiftMenuHandler" );
    cr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, FOTEXT_LIFT(group, floor) );
    for(uint i=0, j=1; j<=floors_in_group; ++j) {
        if(j==floor) {
            continue;
        }
        cr.SayMsg( SAY_DIALOGBOX_BUTTON( i ), TEXTMSG_TEXT, FOTEXT_LIFT(group, j));
        i+=1;
    }
}

Item@ FindLiftItem(Map& map, uint16 hexX, uint16 hexY) {
    Item@ item = map.GetItem(hexX, hexY-1, PID_LIFT_1);
    if(item is null) {
        return map.GetItem(hexX, hexY-1, PID_LIFT_2);
    }
    return item;
}

void answer_LiftMenuHandler( Critter& player, uint answerI, string& answerS ){
    Map@ player_map = player.GetMap();
    if(player_map is null) {
        Log("Player "+player.Id+" answers lift menu while on global");
        return;
    }
    Item@ item = FindLiftItem(player_map, player.HexX, player.HexY);
    if(item is null) {
        Log("Player "+player.Id+" answers lift menu but there is no lift item under him");
        return;
    }
    //uint group = item.Val1;
    uint floor = item.Val2;

    uint next_floor = answerI+1;
    if( floor<=next_floor ) {
        next_floor += 1;
    }
    //player.Say(SAY_NETMSG, "floor in group: "+floors_in_group+", answerI: "+answerI+", next_floor: "+next_floor);
    MoveLiftTo( item, next_floor );
}

void MoveLiftTo( Item& item, uint next_floor) {
    uint group = item.Val1;
    uint floor = item.Val2;
    //player.Say(SAY_NETMSG, "group: "+group+", floor: "+floor);

    if (!IsSettingsValid(group, floor)) {
        return;
    }

    uint16 prev_hexX = 0, prev_hexY = 0;
    Map@ prev_map = item.GetMapPosition (prev_hexX, prev_hexY);
    if( prev_map is null ) {
        LiftDebug("Lift isn't on the map", item);
        return;
    }
    
    uint[]@ group_ids = lifts_ids[group-1];
    uint floors_in_group = group_ids.length()-1;
    
    if(next_floor == floor) {
        //we are already on this floor
        return;
    }
    if( next_floor > floors_in_group) {
        LiftDebug("Next floor is highter than maximum", item);
        return;
    }

    uint next_floor_item_id = group_ids[next_floor];

    if(next_floor_item_id == 0) {
        LiftDebug("Gap in floors", item);
        return;
    }

    Item@ next_lift = GetItem(next_floor_item_id);
    if(next_lift is null) {
        LiftDebug("Next lift with item.Id "+next_floor_item_id+" is invalid", item);
        return;
    }
    uint16 next_hexX = 0, next_hexY = 0;
    Map@ next_map = next_lift.GetMapPosition (next_hexX, next_hexY);
    if(next_map is null) {
        LiftDebug("Next lift with item.Id "+next_floor_item_id+" isn't on map", item);
        return;
    }
    //player.Say(SAY_NETMSG, "hexX: "+hexX+", hexY: "+hexY);
    //player.TransitToMap(next_map.Id, hexX, hexY, 2);
    uint[]@ hexes = GetLiftHexes(group_ids[0]);
    if(hexes is null) {
        //hexY+=1;
        //player.TransitToMap(next_map.Id, hexX, hexY, 2);
        LiftDebug("No hex settings for this lift item prototype", item);
        return;
    } else {
        for(uint i=1, len=hexes.length(); i<len; i+=2) {
            uint diff_hexX = hexes[i];
            uint diff_hexY = hexes[i+1];
            Critter@ cr = prev_map.GetCritter(prev_hexX+diff_hexX, prev_hexY+diff_hexY);
            if( cr is null ) {
                continue;
            }
            cr.TransitToMap(next_map.Id, next_hexX+diff_hexX, next_hexY+diff_hexY, 6);
        }
    }
}