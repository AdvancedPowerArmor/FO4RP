                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

bool hashes_inited=false;

uint[][]hashes_sand((8));

void init_hashes()
{
	string dir="art/tiles/",
	edg="edg",
	frm=".frm";
	
	for(uint type=0;type<(8);type++)
	{
		uint[]@data=hashes_sand[type];
		data.resize(0);
		uint i=0;
		
		switch(type)
		{
			case(0):
			{
				for(i=0;i<=4;i++)
				data.insertLast(GetStrHash(dir+"edgs00"+i+frm));
			}break;
			case(1):
			{
				for(i=1000;i<=1003;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(2):
			{
				for(i=2000;i<=2003;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(3):
			{
				for(i=3000;i<=3001;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(4):
			{
				for(i=4000;i<=4008;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(5):
			{
				for(i=5000;i<=5008;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(6):
			{
				for(i=6000;i<=6011;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
			case(7):
			{
				for(i=7000;i<=7003;i++)
				data.insertLast(GetStrHash(dir+edg+i+frm));
			}break;
		}
	}
	
	hashes_inited=true;
}

uint[][]@GetSandHashes()
{
	if(!hashes_inited)
	init_hashes();
	
	return hashes_sand;
} 

void test_hashes(Critter&player,int var,int con,int param2)
{
	bool ck=true;
	
	uint[]@data=null;
	
	for(uint i=0;i<(8);i++)
	{
		@data=hashes_sand[i];
		for(uint k=0,len=data.length();k<len;k++)
		{
			if(data[k]!=0)
			continue;
			ck=false;
			player.Say((11),"В массиве #"+i+" хэш #"+k+" нулевой");
		}
	}
	if(ck)
	player.Say((11),"Все ок.");
}

uint8 checkSand(Map&map,uint16 tx,uint16 ty)
{
	if(!hashes_inited)
	init_hashes();
	
	uint hash=map.GetTile(tx,ty);
	if(hash==0)
	return 0;
	
	uint[]@data=null;
	uint8 answer=0;
	
	for(uint i=0;i<(8);i++)
	{
		@data=hashes_sand[i];
		for(uint k=0,len=data.length();k<len;k++)
		{
			if(hash!=data[k])
			continue;
			answer|=((0x01)<<i);
			return answer;
		}
	}
	return 0;
}

bool checkSand(Map&map,uint16 from_tx,uint16 from_ty,uint16 to_tx,uint16 to_ty)
{
	return checkSand(map,from_tx,from_ty,to_tx,to_ty,true);
}

bool checkSand(Map&map,uint16 from_tx,uint16 from_ty,uint16 to_tx,uint16 to_ty,bool fromNtoE)
{
	if(!hashes_inited)
	init_hashes();
	
	int lenY=(to_ty-from_ty),
	lenX=(to_tx-from_tx);
	
	if(lenX==0&&lenY==0)
	return false;
	
	int signX=((lenX>=0)?1:-1),
	signY=((lenY>=0)?1:-1),
	hash=0;
	
	uint lenA=0,lenB=0;
	
	if(fromNtoE)
	{
		lenA=abs(lenX)+1;
		lenB=abs(lenY)+1;
	}
	else
	{
		lenB=abs(lenX)+1;
		lenA=abs(lenY)+1;
	}
	
	bool ck=true;
	
	for(int y=0;y<lenA;y++)
	{
		for(int x=0;x<lenB;x++)
		{
			if(fromNtoE)
			hash=map.GetTile(from_tx+(signX*y),from_ty+(signY*x));
			else
			hash=map.GetTile(from_tx+(signX*x),from_ty+(signY*y));
			if(hash==0)
			return false;
			ck=true;
			for(uint i=0;ck&&i<(8);i++)
			{
				for(uint k=0,len=hashes_sand[i].length();ck&&k<len;k++)
				{
					if(hash!=hashes_sand[i][k])
					continue;
					ck=false;
				}
			}
			if(ck)
			return false;
		}
	}
	
	return true;
}

