#include "_macros.fos"
#include "_global_events.fos"

import void DropDrugEffects( Critter& cr ) from "drugs";
import void DropPoison( Critter& cr ) from "poison";
import void DropRadiation( Critter& cr ) from "radiation";

import void DontPickItUp( Critter& cr ) from "arcade_menu";
// import void SkinMenu(Critter@ cr) from "arcade_menu";
import void ArcadeDead( Critter& cr, uint8 time ) from "arcade_menu";
import void StartArcadeMenu( Critter@ cr ) from "arcade_menu";
import void ShowHiveButtons( Critter& cr ) from "arcade_menu";

// import bool ChangeWildness(uint i, int delta) from "globalmap_group";
import bool ChangeWildness( uint16 x, uint16 y, int delta ) from "globalmap_group";
// import uint GetWildness(uint16 x, uint16 y) from "globalmap_group";
import void ChangeMonsterCount( Critter& cr, bool increase ) from "globalmap_group";
import void ChangeMonsterCount( Critter& cr, uint8 count, bool increase ) from "globalmap_group";
import void GlobalCellPopulation() from "globalmap_group";
import void GlobalCellSpawnLo() from "globalmap_group";

import uint GetAllPlayers( Critter@[]& crs ) from "manager";
//
import void Item_SetFrame( Item& item, uint8 frame ) from "item";

import void ObjectTimeLoop() from "map_satter_objects";


// interface GameMode
// {
// void LeadIn(Critter& cr);
// void Dead(Critter& cr);
// }


// LVAR_GAME_ADV_ACTIVATION_TIME
// LVAR_GAME_ADV_ACTIVATION_AUTHOR

bool SwitchGameMode( Critter& cr, int mode )
{
    if( cr.Param[ QST_GAMEMODE ] != GAME_START )
    {
        Log( "Невозможно сменить гейммод у " + GetPlayerName( cr.Id ) + " (" + cr.Id + ")" );
        return false;
    }
    if( mode <= GAME_START || mode >= GAME_MAX )
    {
        Log( "Неверный целевой гейммод, " + GetPlayerName( cr.Id ) + " (" + cr.Id + ")" );
        return false;
    }

    cr.ParamBase[ QST_GAMEMODE ] = mode;
    return true;
}

bool IsInGame( Critter& cr )
{
    return ( cr.WorldX < 350 || cr.WorldY < 600 );
}


class Gameplay : iManagerModule, iManager_loop,
      iManager_critter_init, iManager_critter_finish,
      iManager_critter_idle, iManager_critter_dead, iManager_critter_respawn,
      iManager_map_critter_in, iManager_map_critter_out,
      iManager_world_save, iManager_time  // , iManager_player_registration, iManager_player_login, iManager_time
{
    Gameplay()
    {
        AddStartCallback( "gameplay", "start" );
    }
    bool manager_init()
    {
        // вызывается в порядке приоритетов
        return true;
    }
    uint global_loop()
    {
        return uint( -1 );
    }
    bool global_critter_init( Critter& cr, bool firstTime )
    {
        if( cr.IsNpc() )
            return true;

        if( firstTime )
        {
            cr.ParamBase[ QST_GAMEMODE ] = GAME_INVALID;

			for(uint y=0; y<__GlobalMapHeight; y++)
				for(uint x=0; x<__GlobalMapWidth; x++)
					cr.SetFog(x, y, FOG_NONE);

            /*uint zoneX = cr.WorldX / __GlobalMapZoneLength;
            uint zoneY = cr.WorldY / __GlobalMapZoneLength;
            cr.SetFog( zoneX, zoneY, FOG_FULL );
            cr.SetFog( zoneX - 1, zoneY - 1, FOG_FULL );
            cr.SetFog( zoneX, zoneY - 1, FOG_FULL );
            cr.SetFog( zoneX + 1, zoneY - 1, FOG_FULL );
            cr.SetFog( zoneX - 1, zoneY, FOG_FULL );
            cr.SetFog( zoneX + 1, zoneY, FOG_FULL );
            cr.SetFog( zoneX - 1, zoneY + 1, FOG_FULL );
            cr.SetFog( zoneX, zoneY + 1, FOG_FULL );
            cr.SetFog( zoneX + 1, zoneY + 1, FOG_FULL );*/
        }

        if( cr.Param[ QST_GAMEMODE ] == GAME_INVALID )
        {
            if( TeleportToStart( cr ) )
                cr.ParamBase[ QST_GAMEMODE ] = GAME_START;
            else
            {
                cr.Disconnect();
                return false;
            }
        }

        Map@ map = cr.GetMap();

        if( !IsInGame( cr ) )
        {
            if( cr.ParamBase[ QST_GAMEMODE ] > GAME_START && (map is null) )
            {
                CreateModeStart( cr );
            }
        }
        else
        {
            if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
            {
                DontPickItUp( cr );
                cr.ToDead( 0, null );
            }
        }

        AfterLogin( cr );

        return true;
    }
    bool global_critter_finish( Critter& cr, bool toDelete )
    {
        return true;
    }
    bool global_critter_idle( Critter& cr )
    {
        if( cr.IsDead() && cr.Stat[ ST_REPLICATION_TIME ] >= 0 && cr.Timeout[ TO_REPLICATION ] == 0 )
        {
            if( !RespawnCritter( cr ) )
                cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 10 );
        }
        if( __Zombies && !cr.IsDead() && cr.Param[ ST_BODY_TYPE ] == BT_ZOMBIE && cr.Param[ TO_DEAD ] == 0 )
            cr.ToDead( ANIM2_DEAD_FRONT, null );


        return true;
    }
    bool global_critter_dead( Critter& cr, Critter@ killer )
    {
        Map@ map = cr.GetMap();
        if( map is null )
        {
            Log( "Error! Death map is null" );
            return false;
        }

        if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
            old_arcade_dead( cr, killer );
        else
        {
            if( killer !is null and killer.Param[ QST_GAMEMODE ] == GAME_ARCADE )
                old_arcade_kill( cr, killer );

            old_drop_stuff_if_bluddy( cr, map );
        }

        // if(cr.IsPlayer() && cr.Param[QST_GAMEMODE]!=GAME_ARCADE) act_var_set(cr, ACT_DEAD); // && cr.CondExt>COND_DEAD_BURST &&

        int replTime = cr.Stat[ ST_REPLICATION_TIME ];
        if( cr.Stat[ ST_BODY_TYPE ] == BT_ROBOT && cr.IsPlayer() )
            replTime = -1;

        if( replTime < 0 )
        {
            if( cr.StatBase[ ST_BODY_TYPE ] > 0 )
            {
                ChangeMonsterCount( cr, 1, false );
            }
            return true;
        }         // No respawn

        if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        {
            replTime = REAL_SECOND( 10 );
        }
        else if( replTime == 0 )     // Take default values
        {
            if( cr.IsPlayer() )
            {
                /*if(act_var_check(cr)) replTime=max(abs(cr.Stat[ST_CURRENT_HP])-30, 0)*2+10;
                   else replTime=15;*/
                if( cr.Anim2Dead <= ANIM2_DEAD_BURST )
                    replTime = REAL_MINUTE( 30 );
                else
                    replTime = REAL_MINUTE( 3 );
                // replTime*=REAL_SECOND(1);
            }
            else
            {
                int team = cr.Stat[ ST_TEAM_ID ];
                if( team == TEAM_DEATHCLAW_METRA || team == TEAM_ALIEN_METRA || team == TEAM_FIREGECKO_METRA || team == TEAM_CENTAUR_METRA )
                {
                    replTime = REAL_HOUR( 3 );
                }
                else
                {
                    replTime = Random( 30, 60 );                // 30-60 minutes
                    replTime *= REAL_MINUTE( 1 );
                }
            }
        }
        else
        {
            replTime *= REAL_MINUTE( 1 );
        }

        cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + replTime;

        return true;
    }

    bool RespawnCritter( Critter& cr )
    {
        Map@ dieMap = cr.GetMap();

        if( dieMap is null && cr.StatBase[ QST_GAMEMODE ] != GAME_ARCADE )
        {
            // Continue dead
            Log( "Critter #" + cr.Id + " is dead and on global. WTF?" );
            return false;
        }
        if( cr.IsNpc() )
        {
            return respawn_npc( cr, dieMap );
        }

        if( cr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
            return false;

        int GM = cr.Param[ QST_GAMEMODE ];

        if( GM == GAME_ARCADE )
        {
            Location@ loc = GetLocationByPid( 94, 0 );

            if( loc is null )
            {
                uint locid = CreateLocation( 94, 525, 75, null );
                @loc = GetLocation( locid );

                if( not valid( loc ) )
                {
                    Log( "can't create dead loc" );
                    return false;
                }
            }
            Map@ map = null;
            @map = loc.GetMapByIndex( 0 );

            if( not valid( map ) )
            {
                Log( "can't get dead map" );
                return false;
            }

            if( !cr.TransitToMap( map.Id, 0 ) )
            {
                cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
                return true;
            }
        }

        uint16 hx0 = cr.HexX, hy0 = cr.HexY, hx = 0, hy = 0;
        uint8  condition = cr.Anim2Dead;
        Map@   map = null;

        if( GM == GAME_SURVIVAL || GM == GAME_ADVENTURE )
        {
            Location@ loc = GetLocationByPid( 101, 0 );

            if( loc is null )
            {
                uint locid = CreateLocation( 101, cr.WorldX, cr.WorldY, null );
                @loc = GetLocation( locid );

                if( not valid( loc ) )
                {
                    Log( "can't create dead loc" );
                    return false;
                }
            }

            @map = loc.GetMapByIndex( 0 );

            if( not valid( map ) )
            {
                Log( "can't get dead map" );
                return false;
            }

            if( !cr.TransitToMap( map.Id, 241 ) )
            {
                // Continue dead
                cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
                return true;
            }
        }
        else
        {
            @map = @dieMap;
            hx = cr.HexX;
            hy = cr.HexY;
            if( not map.IsHexPassed( hx, hy ) )
            {
                bool founded = false;
                for( int x = -1; x <= 1; x++ )
                {
                    for( int y = -1; y <= 1; y++ )
                    {
                        if( x == 0 && y == 0 )
                            continue;                                      // Skip direct position
                        if( ( hx % 2 ) == 1 && ( ( x == -1 && y == 1 ) || ( x == 1 && y == 1 ) ) )
                            continue;
                        if( ( hx % 2 ) == 0 && ( ( x == -1 && y == -1 ) || ( x == 1 && y == -1 ) ) )
                            continue;

                        if( map.IsHexPassed( hx + x, hy + y ) )
                        {
                            hx += x;
                            hy += y;
                            founded = true;
                            break;
                        }
                    }
                    if( founded )
                        break;
                }

                if( not founded )
                {
                    // Continue dead
                    cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
                    return true;
                }
            }
            cr.TransitToMap( map.Id, hx, hy, Random( 0, 5 ) );
        }

        if( _CritCanDropItemsOnDead( cr ) )
        {
            Item@[] items;
            cr.GetItems( -1, items );
            // Disable drop of hidden items
            for( uint i = 0, j = items.length(); i < j; i++ )
                if( FLAG( items[ i ].Flags, ITEM_HIDDEN ) )
                    @items[ i ] = null;

            Item@ skeleton;
            if( condition < ANIM2_DEAD_PULSE )
                @skeleton = dieMap.AddItem( hx0, hy0, PID_VAULT_DWELLER_BONES, 1 );
            if( valid( skeleton ) )
            {
                skeleton.Val1 = cr.Id;
                MoveItems( items, skeleton, 0 );
                uint[] values = { dieMap.Id, skeleton.Id };
                CreateTimeEvent( __FullSecond + REAL_MINUTE( 180 ), "e_deleteBody", values, true );

                // set rigth direct
                Item_SetFrame( skeleton, cr.Dir );
            }
            else
                MoveItems( items, dieMap, hx0, hy0 );
        }

        cr.ToLife();
        cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];

        return true;
    }

    bool global_critter_respawn( Critter& cr )
    {
        // if(cr.IsNpc()) {return true;}

        return true;
    }
    bool global_map_critter_in( Map& map, Critter& cr )
    {
        if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        {
            Location @ loc = map.GetLocation();
            int x = 0, y = 0;
            x = loc.WorldX * 0.1;
            y = loc.WorldY * 0.1;
            int Wild1 = 100, Wild2 = 100, Wild = 100;
            if( ABS( x - 7 ) + ABS( y - 7 ) <= 10 )
            {
                Wild1 = ( ABS( x - 7 ) + ABS( y - 7 ) ) * 10;
                Wild1 = CLAMP( Wild1, 0, 100 );
            }
            if( ABS( x - 17 ) + ABS( y - 15 ) <= 8 )
            {
                Wild2 = ( ABS( x - 17 ) + ABS( y - 15 ) + 2 ) * 10;
                Wild2 = CLAMP( Wild2, 0, 100 );
            }
            Wild = CLAMP( Wild, 0, Wild1 );
            Wild = CLAMP( Wild, 0, Wild2 );
            uint8  BonusWild = 0;
            uint16 time = 0;
            uint16 hour = 0;
            GetTime( time, time, time, time, hour, time, time, time );
            if( 7 > hour && hour > 22 )
                BonusWild = 20;                     // bonus wildness at night

            uint8 Wild_delta = cr.Param[ ST_ARCADE_DANGER ] - ( Wild + BonusWild );
            if( Wild_delta <= 0 )
                return true;
            else if( Wild_delta >= 50 )
                cr.ToDead( 0, null );
            else if( Wild_delta >= 40 )
            {
                cr.ParamBase[ ST_NORMAL_ABSORB ] = cr.ParamBase[ ST_NORMAL_ABSORB ] * 0.6 - 1;
                cr.ParamBase[ ST_NORMAL_RESIST ] = cr.ParamBase[ ST_NORMAL_RESIST ] * 0.6 - 1;
                cr.ParamBase[ ST_MELEE_DAMAGE ] = cr.ParamBase[ ST_MELEE_DAMAGE ] * 0.6 - 1;
                cr.ParamBase[ ST_CURRENT_HP ] = cr.ParamBase[ ST_CURRENT_HP ] * 0.5;
                cr.ParamBase[ ST_MAX_LIFE ] = cr.ParamBase[ ST_MAX_LIFE ] * 0.6 - 5;
            }
            else if( Wild_delta >= 30 )
            {
                cr.ParamBase[ ST_NORMAL_ABSORB ] = cr.ParamBase[ ST_NORMAL_ABSORB ] * 0.7 - 1;
                cr.ParamBase[ ST_NORMAL_RESIST ] = cr.ParamBase[ ST_NORMAL_RESIST ] * 0.7 - 1;
                cr.ParamBase[ ST_MELEE_DAMAGE ] = cr.ParamBase[ ST_MELEE_DAMAGE ] * 0.7 - 1;
                cr.ParamBase[ ST_CURRENT_HP ] = cr.ParamBase[ ST_CURRENT_HP ] * 0.7;
                cr.ParamBase[ ST_MAX_LIFE ] = cr.ParamBase[ ST_MAX_LIFE ] * 0.7 - 5;
            }
            else if( Wild_delta >= 20 )
            {
                cr.ParamBase[ ST_NORMAL_ABSORB ] = cr.ParamBase[ ST_NORMAL_ABSORB ] * 0.8 - 1;
                cr.ParamBase[ ST_NORMAL_RESIST ] = cr.ParamBase[ ST_NORMAL_RESIST ] * 0.8 - 1;
                cr.ParamBase[ ST_MELEE_DAMAGE ] = cr.ParamBase[ ST_MELEE_DAMAGE ] * 0.8 - 1;
                cr.ParamBase[ ST_CURRENT_HP ] = cr.ParamBase[ ST_CURRENT_HP ] * 0.8;
                cr.ParamBase[ ST_MAX_LIFE ] = cr.ParamBase[ ST_MAX_LIFE ] * 0.8 - 5;
            }
            else if( Wild_delta >= 10 )
            {
                cr.ParamBase[ ST_NORMAL_ABSORB ] = cr.ParamBase[ ST_NORMAL_ABSORB ] * 0.9 - 1;
                cr.ParamBase[ ST_NORMAL_RESIST ] = cr.ParamBase[ ST_NORMAL_RESIST ] * 0.9 - 1;
                cr.ParamBase[ ST_MELEE_DAMAGE ] = cr.ParamBase[ ST_MELEE_DAMAGE ] * 0.9 - 1;
                cr.ParamBase[ ST_CURRENT_HP ] = cr.ParamBase[ ST_CURRENT_HP ] * 0.9;
                cr.ParamBase[ ST_MAX_LIFE ] = cr.ParamBase[ ST_MAX_LIFE ] * 0.9 - 5;
            }
            return true;
        }
        return true;
    }
    bool global_map_critter_out( Map& map, Critter& cr )
    {
        return true;
    }
    bool global_world_save()
    {
        return true;
    }
    bool global_player_registration( uint ip, string& name, uint& textMsg, uint& strNum )
    {
        return true;
    }
    bool global_player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum )
    {
        Critter@ cr = GetCritter( id );
        if( cr !is null )
            AfterLogin( cr );
        return true;
    }
    void AfterLogin( Critter& cr )
    {
        // ShowHiveButtons(cr);
        cr.AddTimeEvent( "cte_ban", 2, 0, 0 );

        if( cr.Param[ QST_GAMEMODE ] != GAME_ARCADE )
        {
            // Log("count "+cr.GetTimeEvents(CTE_STUDY, null, null, null));
            if( cr.GetTimeEvents( CTE_STUDY, null, null, null ) < 1 )
            {
                cr.AddTimeEvent( "cte_IncreaseStudyExp", ( 60 * 15 ) * __TimeMultiplier, CTE_STUDY, 0 );
                Log( "count" );
            }

            if( cr.GetTimeEvents( CTE_HUNGER, null, null, null ) < 1 )
            {
                cr.AddTimeEvent( "cte_Hunger", ( ( cr.Stat[ ST_ENDURANCE ] + cr.Stat[ ST_STRENGTH ] ) * 60 ) * __TimeMultiplier, CTE_HUNGER, 0 );
                Log( "count1" );
            }
            
            if( cr.GetTimeEvents( CTE_EXP, null, null, null ) < 1 )
            {
                cr.AddTimeEvent( "cte_Exp", 15 * 60  * __TimeMultiplier, CTE_EXP, 0 );
                Log( "count1" );
            }
            // cr.AddTimeEvent("cte_Hunger", (cr.)*__TimeMultiplier, CTE_STUDY, 0);
        }
    }

    bool global_time( int8 type )
    {
        // Log("time type "+type);
        /*
           if((type&0xF)>=TIME_NEW_<MINUTE/HOUR/DAY/MONTH/YEAR>)
           {
                ...
           }
           if(FLAG(type, TIME_NEW_WEEK))
           {
                ...
           }
         */

        if( type == TIME_NEW_HOUR )
        {
            ObjectTimeLoop();             // satter objects
/*
            Critter@[] crs;
            GetAllPlayers( crs );

            for( uint16 i = 0, j = crs.length(); i < j; ++i )
            {
                uint hunger = ABS( int(5 + crs[ i ].Stat[ ST_STRENGTH ]) - crs[ i ].Stat[ ST_ENDURANCE ] );              // ABS(int(crs[i].Stat[ST_ENDURANCE] * 2 - crs[i].Stat[ST_STRENGTH] * 3));
                uint thrist = ABS( int(5 + crs[ i ].Stat[ ST_STRENGTH ]) - crs[ i ].Stat[ ST_ENDURANCE ] );
                crs[ i ].StatBase[ ST_HUNGER ] -= hunger;
                crs[ i ].StatBase[ ST_THRIST ] -= thrist;

                if( ( crs[ i ].Param[ QST_GAMEMODE ] == GAME_SURVIVAL || crs[ i ].Param[ QST_GAMEMODE ] == GAME_ADVENTURE ) && crs[ i ].StatBase[ ST_LEVEL ] < __LevelCap )
                {
                    crs[ i ].StatBase[ ST_EXPERIENCE ] += 50;
                }

                Map @ map = crs[ i ].GetMap();
                if( !(map is null) )
                {
                    if( map.GetData( 25 ) > 0 )
                    {
                        GameVar @ dyspnea = GetLocalVar( LMVAR_Dyspnea, map.Id );
                        if( !(dyspnea is null) )
                        {
                            crs[ i ].StatBase[ ST_DYSPNEA ] -= dyspnea.GetValue() / 3;
                        }
                    }
                    else
                    {
                        crs[ i ].StatBase[ ST_DYSPNEA ] += crs[ i ].Stat[ ST_ENDURANCE ] * 10;
                    }

                }
                // crs[i].Say(SAY_NETMSG, "hunger damage "+hunger);
                        }*/
        }


        if( type == TIME_NEW_DAY )       // 142
        {
            GlobalCellPopulation();
            GlobalCellSpawnLo();
        }
        return true;
    }
}

uint cte_ban( Critter& player, int identifier, uint& rate )
{
    if( player.Param[ QST_GAMEMODE ] == GAME_ARCADE )
    {
        Map@ map = GetMapByPid( 94, 0 );
        if( !valid( map ) )
            player.Say( SAY_NETMSG, "Нет карты аркады, обратитесь к Мастерам." );
        player.TransitToMap( map.Id, 0 );
    }
    // player.RunClientScript("client_main@CheckHardBan", 0, 0, 0, null, null);
    return 0;
}

uint cte_IncreaseStudyExp( Critter& cr, int identifier, uint& rate )
{
    // GameVar@ studyExp = GetLocalVar(LVAR_study_exp, cr.Id); //weariness for teaching
    // GameVar@ studyExpMax = GetLocalVar(LVAR_study_exp_max, cr.Id); //weariness for teaching
    uint16 studyExp = cr.StatBase[ ST_STUDY_EXP ];
    uint16 studyExpMax = cr.StatBase[ ST_STUDY_EXP_MAX ];

    // cr.Say(SAY_NETMSG, "studyExp start ");

    if( studyExpMax > studyExp )
    {
        uint16 studyTemp = studyExpMax / 100;
        studyTemp = CLAMP( studyExp + studyTemp, 0, studyExpMax > 100 ? 1000 : 100 );
        // studyExp.opAssign(studyTemp);
        cr.StatBase[ ST_STUDY_EXP ] = studyTemp;
        // cr.RunClientScript("client_screen_teach@SetMaxExp", studyTemp, 0, 0, "", null);
        // cr.StatBase[ST_STUDY_EXP] += studyExp;
        // cr.Say(SAY_NETMSG, "studyExp "+studyTemp);
    }

    return ( 60 * 15 ) * __TimeMultiplier;
}

uint cte_Hunger( Critter& cr, int identifier, uint& rate )
{
    cr.StatBase[ ST_HUNGER ] -= 1;
    cr.StatBase[ ST_THRIST ] -= 1;

    return ( ( cr.Stat[ ST_ENDURANCE ] + cr.Stat[ ST_STRENGTH ] ) * 60 ) * __TimeMultiplier;
}

uint cte_Exp( Critter& cr, int identifier, uint& rate ){
	cr.StatBase[ST_EXPERIENCE] += 50;
	
	return 15 * 60 * __TimeMultiplier;
}

Gameplay gameplay;

void start()
{
    iManagerModule@  module = gameplay;
    iManagerElement@ manager = manager_add_module( module, "Gameplay", 40 );
    if( manager is null )
        return;

    // manager.TimeChangeCall() = TIME_NEW_<MINUTE/HOUR/DAY/MONTH/YEAR>;
}

// используется
bool CreateModeStart( Critter& cr )
{
    return TeleportToStart( cr );
}

// используется
bool TeleportToStart( Critter& cr )
{
    // Map@ modoc = GetMapByPid  ( /*MAP_Modoc*/ 51, 0);
    Map@ modoc = GetMapByPid( /*Map_start*/ 92, 0 );

    if( valid( modoc ) && cr.TransitToMap( modoc.Id, 0 ) )
    {
        /*zoneX=cr.WorldX/__GlobalMapZoneLength;
           zoneY=cr.WorldY/__GlobalMapZoneLength;
           cr.SetFog(zoneX  ,zoneY  ,FOG_NONE);
           cr.SetFog(zoneX-1,zoneY-1,FOG_HALF);
           cr.SetFog(zoneX  ,zoneY-1,FOG_HALF);
           cr.SetFog(zoneX+1,zoneY-1,FOG_HALF);
           cr.SetFog(zoneX-1,zoneY  ,FOG_HALF);
           cr.SetFog(zoneX+1,zoneY  ,FOG_HALF);
           cr.SetFog(zoneX-1,zoneY+1,FOG_HALF);
           cr.SetFog(zoneX  ,zoneY+1,FOG_HALF);
           cr.SetFog(zoneX+1,zoneY+1,FOG_HALF);
         */
        return true;
    }
    Log( "Transit to start error! PlayerId: " + cr.Id );
    return false;
}

// используется
bool respawn_npc( Critter& cr, Map@ map )
{
    if( not valid( map ) ) // On global, delete
    {
        DeleteNpc( cr );
        return true;
    }

    uint16 hx = cr.HexX,
           hy = cr.HexY;

    if( not map.IsHexPassed( hx, hy ) )
    {
        bool founded = false;
        for( int x = -1; x <= 1; x++ )
        {
            for( int y = -1; y <= 1; y++ )
            {
                if( x == 0 && y == 0 )
                    continue;                              // Skip direct position

                if( __MapHexagonal )
                {
                    if( ( hx % 2 ) == 1 && ( ( x == -1 && y == 1 ) || ( x == 1 && y == 1 ) ) )
                        continue;
                    if( ( hx % 2 ) == 0 && ( ( x == -1 && y == -1 ) || ( x == 1 && y == -1 ) ) )
                        continue;
                }

                if( map.IsHexPassed( hx + x, hy + y ) )
                {
                    hx += x;
                    hy += y;
                    founded = true;
                    break;
                }
            }
            if( founded )
                break;
        }

        if( not founded )
        {
            // Continue dead
            cr.TimeoutBase[ TO_REPLICATION ] = __FullSecond + REAL_MINUTE( 1 );
            return true;
        }
    }

    cr.TransitToMap( map.Id, hx, hy, Random( 0, 5 ) );
    cr.ToLife();

    cr.DropPlanes();
    cr.ClearEnemyStackNpc();
    cr.StatBase[ ST_LAST_WEAPON_ID ] = 0;

    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
            DeleteItem( block );
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }

    cr.DamageBase[ DAMAGE_EYE ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_ARM ] = 0;
    cr.DamageBase[ DAMAGE_RIGHT_LEG ] = 0;
    cr.DamageBase[ DAMAGE_LEFT_LEG ] = 0;

    cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
    cr.Stat[ ST_ACTION_POINTS ] * 100;

    DropPoison( cr );
    DropRadiation( cr );
    DropDrugEffects( cr );
    cr.DropTimers();
    for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
        if( i != TO_KARMA_VOTING )
            cr.TimeoutBase[ i ] = 0;

    return true;
}

// не используется
bool transit_dead( Critter& cr )
{
    if( __Zombies && cr.Param[ ST_BODY_TYPE ] == BT_ZOMBIE )
        return false;

    Location@ loc = GetLocationByPid( 6, 0 );

    if( loc is null )
    {
        uint locid = CreateLocation( 6, cr.WorldX, cr.WorldY, null );
        @loc = GetLocation( locid );

        if( not valid( loc ) )
        {
            Log( "can't create dead loc" );
            return false;
        }
    }

    Map@ map = loc.GetMapByIndex( 0 );

    if( not valid( map ) )
        return false;

    cr.TransitToMap( map.Id, 241 );

    return true;
}



bool transit_modoc( Critter& player )
{
    // if(player.CountItem(905)==0) player.AddItem(905,1);

    Map@ modoc = GetMapByPid( MAP_Modoc, 0 );
    if( valid( modoc ) && player.TransitToMap( modoc.Id, 0 ) )
    {
        uint zoneX = player.WorldX / __GlobalMapZoneLength;
        uint zoneY = player.WorldY / __GlobalMapZoneLength;
        player.SetFog( zoneX, zoneY, FOG_NONE );
        player.SetFog( zoneX - 1, zoneY - 1, FOG_HALF );
        player.SetFog( zoneX, zoneY - 1, FOG_HALF );
        player.SetFog( zoneX + 1, zoneY - 1, FOG_HALF );
        player.SetFog( zoneX - 1, zoneY, FOG_HALF );
        player.SetFog( zoneX + 1, zoneY, FOG_HALF );
        player.SetFog( zoneX - 1, zoneY + 1, FOG_HALF );
        player.SetFog( zoneX, zoneY + 1, FOG_HALF );
        player.SetFog( zoneX + 1, zoneY + 1, FOG_HALF );
        player.SetKnownLoc( false, LOCATION_Modoc );
        return true;
    }

    Log( "Activation: final transit panic! PlayerId: " + player.Id );
    return false;
}

bool start_items( Critter& cr )
{
    Item@[] items;
    cr.GetItems( -1, items );

    for( uint i = 0; i < items.length(); i++ )
    {
        Item@ item = items[ i ];
        if( !valid( item ) )
            continue;
        if( item.GetProtoId() == PID_ACTIVATOR )
            DeleteItem( item );
    }

//	if(cr.CountItem(PID_ACTIVATOR)==0)
//	{


    Item@ hand_item = _CritGetItemHand( cr );
    if( valid( hand_item ) )
        _CritMoveItem( cr, hand_item, SLOT_INV );

    Item@ doc = cr.AddItem( PID_ACTIVATOR, 1 );
    if( valid( doc ) )
        cr.MoveItem( doc.Id, 1, SLOT_HAND1 );

    return true;


/*
        }
        else
        {
                Item@ hand_item = _CritGetItemHand(cr);
                if(valid(hand_item))
                {
                        if(hand_item.GetProtoId()==906) return true;
                        _CritMoveItem(cr,hand_item,SLOT_INV);
                }
                Item@ doc = cr.GetItem (PID_ACTIVATOR, -1);

                if(valid(doc))
                {
                        cr.MoveItem(doc.Id,1,SLOT_HAND1);
                        return true;
                }
        }
 */
//	return false;
}

bool player_items( Critter& cr )
{
    Item@[] items;
    cr.GetItems( -1, items );

    for( uint i = 0; i < items.length(); i++ )
    {
        Item@ item = items[ i ];
        if( !valid( item ) )
            continue;
        uint16 pid = item.GetProtoId();
        if( pid == PID_ACTIVATOR or pid == PID_SKIN_CHANGER )
            DeleteItem( item );
    }

    cr.AddItem( PID_SKIN_CHANGER, 1 );
    return true;
}

// используется
void old_arcade_dead( Critter& cr, Critter@ killer )
{
    /*
       uint8 Body=cr.CrType;
       if((Body==51||Body==60||Body==100||Body==81||Body==25||Body==23||Body==60))
       {
            Item@ spec=cr.GetItem(0, SLOT_HAND1); //TabaK. Удаление спецоружия.
            if(valid(spec))
            {
                    if(spec.GetProtoId()==PID_CLAW_EXT || spec.GetProtoId()==PID_FIREBREATH) DeleteItem(spec);
            }
            else
            {
                    @spec=cr.GetItem(0, SLOT_HAND2);
                    if(valid(spec))
                    {
                            if(spec.GetProtoId()==PID_CLAW_EXT || spec.GetProtoId()==PID_FIREBREATH) DeleteItem(spec);
                    }
            }*/

    /*
       GameVar@ firegeckoNow=GetGlobalVar(GVAR_firegecko_now);
       GameVar@ alienNow=GetGlobalVar(GVAR_alien_now);
       GameVar@ deathclawNow=GetGlobalVar(GVAR_deathclaw_now);
       GameVar@ flocentNow=GetGlobalVar(GVAR_floaterandcentaur_now);
       GameVar@ clawNow=GetGlobalVar(GVAR_claw_now);
       GameVar@ clawKidNow=GetGlobalVar(GVAR_clawkid_now);

       switch(Body)
       {
       case 23 : flocentNow.opAddAssign(flocentNow.GetValue() > 0 ? -1 : 0);
       case 25 : flocentNow.opAddAssign(flocentNow.GetValue() > 0 ? -1 : 0);
       case 60:  clawKidNow.opAddAssign(clawKidNow.GetValue() > 0 ? -1 : 0);
       case 80:  clawNow.opAddAssign(clawNow.GetValue() > 0 ? -1 : 0);
       case 81 : firegeckoNow.opAddAssign(firegeckoNow.GetValue() > 0 ? -1 : 0);
       case 86 : alienNow.opAddAssign(alienNow.GetValue() > 0 ? -1 : 0);
       case 100: deathclawNow.opAddAssign(deathclawNow.GetValue() > 0 ? -1 : 0);
       }
       }
     */

    Item@[] items;
    cr.GetItems( -1, items );
    if( items.length() != 0 )
    {
        DeleteItems( items );
    }
    // ArcadeDead(cr, 0);
}

// используется
void old_arcade_kill( Critter& cr, Critter@ killer )
{
    if( cr.Stat[ ST_BODY_TYPE ] < 5 && killer.Param[ QST_GAMEMODE ] == GAME_ARCADE )
    {
        int vLevel = cr.Stat[ ST_LEVEL ];
        int kBody = killer.Stat[ ST_BODY_TYPE ];
        if( kBody > 4 && kBody < 10 || kBody > 10 )
            killer.StatBase[ ST_EXPERIENCE ] += vLevel * 100;

        // ChangeWildness(cr.WorldX/10, cr.WorldY/10, 10);
    }
}

// используется
void old_drop_stuff_if_bluddy( Critter& cr, Map& map )
{
    if( ( cr.Anim2Dead == ANIM2_DEAD_PULSE_DUST || cr.Anim2Dead == ANIM2_DEAD_EXPLODE ) && _CritCanDropItemsOnDead( cr ) )
    {
        // Drop all, exclude armor
        Item@[] items;
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
        // Disable drop of hidden items
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
            if( FLAG( items[ i ].Flags, ITEM_GAG ) )
            {
                Item@ item = items[ i ];
                if( valid( item ) )
                    DeleteItem( item );
                @items[ i ] = null;
            }
            else if( FLAG( items[ i ].Flags, ITEM_HIDDEN ) )
                @items[ i ] = null;
        }
        MoveItems( items, map, cr.HexX, cr.HexY );
    }
}

// не используется
void old_replication( Critter& cr )
{
    GameVar@ act = GetLocalVar( LVAR_activationStatus, cr.Id );
    GameVar@ former = GetLocalVar( LVAR_former_act, cr.Id );
    string   myId;
    string   str;
    myId += cr.Id;
    uint16   X = 0, Y = 0;
    file     f;
    uint     step = 0;
    if( f.open( "replwait.cfg", "r" ) >= 0 )
    {
        f.readString( f.getSize(), str );
        f.close();
    }
    // Log("содержимое файла:" + str);
    string@[] @ waiters = split( str, "|" );
    while( step < waiters.length() - 1 )
    {
        if( waiters[ step ] == myId )
        {
            file f;
            // remove_from_array(waiters, step);
            waiters.removeAt( step );
            string newConfig = join( waiters, "|" );
            if( f.open( "replwait.cfg", "w" ) >= 0 )
            {
                f.writeString( newConfig );
                f.close();
            }
            Map@ map = GetMapByPid( 81, 0 );
            if( valid( map ) )
            {
                uint8 z = 0;
                uint8 count = map.CountEntire( 129 );
                while( z < count - 1 )
                {
                    map.GetEntireCoords( 129, z, X, Y );
                    if( map.IsHexPassed( X, Y ) )
                        z = count - 1;
                    z++;
                }
                if( cr.IsDead() )
                    cr.ToLife();
                cr.TransitToMap( map.Id, X, Y, Random( 0, 5 ) );
                act = former;
                step = waiters.length() - 1;
            }
        }
        else
            step++;
    }
}

uint e_deleteBody( uint[] @ values )
{
    Map@  map = GetMap( values[ 0 ] );
    Item@ item = GetItem( values[ 1 ] );
    Item@[] items;
    if( valid( item ) )
    {
        item.GetItems( -1, items );

        if( valid( map ) )
            MoveItems( items, map, item.HexX, item.HexY );
        else
            DeleteItems( items );

        DeleteItem( item );
    }
    return 0;
}
