                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

import bool CheckGard(Map&map,uint16 hexX,uint16 hexY)from"farm";                            

void _InitPlant(Item&item,bool firstTime)
{
	
	if(firstTime)
	{
		uint16 proto=item.GetProtoId();
		
		if(item.GetType()!=(15))
		return;
		
		uint8 hashNum=item.Val3;
		item.Val2=1;  
		
		CPlant@plant;
		
		switch(proto)
		{
			case(1600):
			@plant=CRadCvet();
			break;
			case(1610):
			@plant=CCabbage();
			break;
			case(1620):
			@plant=CCorn();
			break;
			default:
			break;
		}
		
		if(!(plant is null))
		{
			hashNum=plant.PlantType;
		}
		
		item.Val3=hashNum;
		
		item.Update();
	}
	
	if(item.Val1==0)
	{
		item.SetEvent((5),"_DropPlant");
		if(item.Accessory==(2)&&item.Val0!=0)
		item.SetEvent((4),"_SkillPlant");
	}else{
		item.SetEvent((4),"_SkillPlant");
		item.SetEvent((7),"_WalkPlant");
		item.SetEvent((3),"_OnMePlant");
	}
	
	if(item.Val1==0||item.Val1==3)
	{
		(item.Flags=(item.Flags)|((0x10000000)));
	}
	else
	(item.Flags=((item.Flags)&(~((0x10000000))))); 
	
	item.SetEvent((2),"_UsePlant");
}

import void AffectRadiation(Critter&cr,int value)from"radiation";
import void AffectPoison(Critter&cr,int value)from"poison";

bool _UsePlant(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	CPlant@plant=GetCPlant(item.Val3);
	if((@onCritter!=null)||(@onItem!=null)||(@onScenery!=null)||plant is null)
	return false;
	
	if(item.Val1==0)
	{
		AffectRadiation(cr,1);
		AffectPoison(cr,1);
		
		int heal=cr.Param[(7)]-cr.Param[(72)],
		good=item.Val2;
		if(good>heal)
		good=heal;
		if(good>15)
		good=15;
		cr.ParamBase[(72)]+=good;
		DeleteItem(item);
	}
	else if(item.Val1==plant.SeedCycle)
	{
		for(uint i=0,len=Random(1,3);i<len;i++)
		{
			Item@pl=cr.AddItem(plant.BasePid,1);
			pl.Val2=item.Val2+Random(0,1);
			pl.Val3=item.Val3;
			pl.SetScript("plant@_InitPlant");
		}
		DeleteItem(item);
	}
	else
	return false;
	
	return true;
}

void _DropPlant(Item&item,Critter&cr)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	if(item.Val1!=0)
	return;
	
	if(map.GetItems(cr.HexX,cr.HexY,null)>1)
	{
		if(cr.IsLife())
		cr.Say((11),"Это тут не прорастет.");
		return;
	}
	
	item.SetEvent((4),"_SkillPlant");
	item.SetEvent((7),"_WalkPlant");
	item.SetEvent((3),"_OnMePlant");
	uint time=0;
	if(CheckGard(map,cr.HexX,cr.HexY))
	{
		time=((4)*60);
		if(cr.IsLife())
		cr.Say((11),"Плод посажен.");
	}
	else
	{
		time=((2)*86400);
		if(cr.IsLife())
		cr.Say((11),"Здесь плод будет прорастать очень долго.");
	}
	
	item.Val0=CreateTimeEvent(__FullSecond+time,"e_ProcessPlant",item.Id,true);
}

bool _SkillPlant(Item&item,Critter&cr,int skill)
{
	if(skill==-1)
	{
		if(item.Val6>0)
		{
			CPlant@plant=GetCPlant(item.Val3);
			if(plant is null)
			return false;
			cr.AddItem(plant.BasePid+plant.MaxCycle+1,item.Val6);
			item.Val6=0;
			cr.Say((11),"Вы собрали плоды");
			return false;
		}
		
		item.SetEvent((4),null);
		if(item.Val0!=0)
		{
			EraseTimeEvent(item.Val0);
			item.Val0=0;
		}  
		
	}else if(skill==(212)){
		
		if(cr.Skill[(217)]>=100){ 
			
			if(item.Val1==2){string msg=("Информация о растении :\nСтадия роста : "+item.Val1+"\\5"+"\nПолив : "+item.Val4+"\\2 \nУдобрения : "+item.Val5+"\\2 \nПлодов : "+item.Val6+"\nСелекция : "+item.Val2);cr.Say((11),msg);}
			else if(item.Val1==3){string msg=("Информация о растении :\nСтадия роста : "+item.Val1+"\\5"+"\nПолив : "+item.Val4+"\\3 \nУдобрения : "+item.Val5+"\\2 \nПлодов : "+item.Val6+"\nСелекция : "+item.Val2);cr.Say((11),msg);}
			else if(item.Val1>=4){string msg=("Информация о растении :\nСтадия роста : "+item.Val1+"\\5"+"\nПолив : "+item.Val4+"\\5 \nУдобрения : "+item.Val5+"\\2 \nПлодов : "+item.Val6+"\nСелекция : "+item.Val2);cr.Say((11),msg);}
			
		}else{
			cr.Say((11),"Недостаточный навык фермерства.");
		}
	}
	return true;           
	
}

void _WalkPlant(Item&item,Critter&cr,bool entered,uint8 dir)
{
	if(entered&&item.Val1>1)
	{
		if(Random(1,95)>5)
		{
			CPlant@plant=GetCPlant(item.Val3);
			plant.Kill(item);
		}
	}
	
}

bool _OnMePlant(Item&item,Critter&cr,Item@usedItem)
{
	cr.Say((5),"Возится с растением");
	if(usedItem is null)
	return true;
	if(item.Val1==0)
	return true;
	
	uint16 pid=usedItem.GetProtoId();
	if(pid==(106)||
	pid==(124)||
	pid==(125)||
	pid==(1627)||
	pid==(533))
	{
		cr.Say((11),"Вы полили растение.");
		item.Val4+=1;
	}
	else if(pid==(1599))
	{
		cr.Say((11),"Вы удобрили растение.");
		item.Val5+=1;
	}
	
	return false;
}

CPlant@GetCPlant(uint8 plantNum)
{
	if(plantNum<0||plantNum>(3))
	return null;
	
	CPlant@tempPlant;
	
	switch(plantNum)
	{
		case(0):
		@tempPlant=CRadCvet();
		break;
		case(1):
		@tempPlant=CCabbage();
		break;
		case(2):
		@tempPlant=CCorn();
		break;
		default:
		break;
	}
	
	return tempPlant;
}

class CRadCvet:CPlant
{
	
	CRadCvet()
	{
		MaxCycle=4;
		SeedCycle=3;
		BasePid=(1600);
		PlantType=(0);
		
		ToWater.insertLast(0);
		ToWater.insertLast(0);
		ToWater.insertLast(0);
		
		ToShit.insertLast(0);
		ToShit.insertLast(1);
		ToShit.insertLast(1);
	}
	
	uint Cycle1(Item&item)
	{
		(item.Flags=(item.Flags)|((0x00000001)));
		item.ChangeProto((1600)+1);
		item.Update();
		
		return((1)*3600);
	}
	
	uint Cycle2(Item&item)
	{
		(item.Flags=((item.Flags)&(~((0x10000000)))));
		(item.Flags=((item.Flags)&(~((0x00000001)))));
		item.ChangeProto((1600)+2);
		item.Update();
		
		return((1)*3600);
	}
	
	uint Cycle3(Item&item)
	{
		(item.Flags=(item.Flags)|((0x10000000)));
		item.ChangeProto((1600)+3);
		item.Val0=0;
		item.Update();
		
		return((1)*3600);
	}
	
	uint Cycle4(Item&item)
	{
		item.ChangeProto((1600)+4);
		
		item.Update();
		return((1)*3600);
	}
}

class CCabbage:CPlant
{
	CCabbage()
	{
		MaxCycle=4;
		SeedCycle=2;
		BasePid=(1610);
		PlantType=(1);
		
		ToWater.insertLast(0);
		ToWater.insertLast(1);
		ToWater.insertLast(1);
		
		ToShit.insertLast(0);
		ToShit.insertLast(1);
		ToShit.insertLast(1);
	}
	
	uint Cycle1(Item&item)
	{
		(item.Flags=(item.Flags)|((0x00000001)));
		item.ChangeProto((1610)+1);
		item.Update();
		
		return((2)*3600);
	}
	
	uint Cycle2(Item&item)
	{
		item.ChangeProto((1610)+2);
		(item.Flags=(item.Flags)|((0x10000000)));
		(item.Flags=((item.Flags)&(~((0x00000001)))));
		item.Update();
		
		return((4)*3600);
	}
	
	uint Cycle3(Item&item)
	{
		item.ChangeProto((1610)+3);
		(item.Flags=(item.Flags)|((0x10000000)));
		item.Val0=0;
		item.Update();
		
		return((3)*3600);
	}
	
	uint Cycle4(Item&item)
	{
		item.ChangeProto((1610)+4);
		
		item.Update();
		return((8)*3600);
	}
}

class CCorn:CPlant
{
	CCorn()
	{
		MaxCycle=5;
		SeedCycle=4;
		BasePid=(1620);
		PlantType=(2);
		
		ToWater.insertLast(0);
		ToWater.insertLast(2);
		ToWater.insertLast(2);
		ToWater.insertLast(2);
		
		ToShit.insertLast(0);
		ToShit.insertLast(1);
		ToShit.insertLast(1);
		ToShit.insertLast(1);
		
	}
	
	uint Cycle1(Item&item)
	{
		(item.Flags=(item.Flags)|((0x00000001)));
		item.ChangeProto((1620)+1);
		item.Update();
		
		return((4)*3600);
	}
	
	uint Cycle2(Item&item)
	{
		item.ChangeProto((1620)+2);
		(item.Flags=((item.Flags)&(~((0x10000000)))));
		(item.Flags=((item.Flags)&(~((0x00000001)))));
		item.Update();
		
		return((3)*3600);
	}
	
	uint Cycle3(Item&item)
	{
		item.ChangeProto((1620)+3);
		(item.Flags=(item.Flags)|((0x10000000)));
		IncreaseFruits(item);
		item.Update();
		
		return((4)*3600);
	}
	
	uint Cycle4(Item&item)
	{
		item.ChangeProto((1620)+4);
		(item.Flags=(item.Flags)|((0x10000000)));
		IncreaseFruits(item);
		item.Val0=0;
		item.Update();
		
		return((2)*3600);
	}
	
	uint Cycle5(Item&item)
	{
		item.ChangeProto((1620)+5);
		
		item.Update();
		return((12)*3600);
	}
}

class CPlant
{
	uint8 PlantType;
	uint8 MaxCycle;
	uint8 SeedCycle;
	uint8[]ToWater;
	uint8[]ToShit;
	uint16 BasePid;
	uint16 CollectPid;
	CPlant()
	{
		PlantType=0;
		MaxCycle=0;
		BasePid=0;
	}
	
	CPlant(uint8 maxCycle)
	{
		MaxCycle=maxCycle;
	}
	
	uint Release(Item&item)
	{
		uint8 hashNum=item.Val3;
		uint time=0;
		
		switch(item.Val1)
		{
			case 1:
			time=Cycle1(item);
			break;
			case 2:
			time=Cycle2(item);
			break;
			case 3:
			time=Cycle3(item);
			break;
			case 4:
			time=Cycle4(item);
			break;
			case 5:
			time=Cycle5(item);
			break;
			default:
			time=0;
		}
		
		return time;
	}
	
	bool CheckWater(Item&item)
	{
		Map@currentMap=GetMap(item.MapId);
		int rain=currentMap.GetRain(); 
		
		if(item.Val1>=4)
		{
			if(item.Val4<=4||item.Val4>=6||Random(0,4)>=4||item.Val5>=3)
			{
				Kill(item);
				return false;
			}
		}
		else if(item.Val1>=3)
		{
			if(item.Val4<=2||item.Val4>=4||Random(0,4)>=4||item.Val5>=3)
			{
				Kill(item);
				return false;
			}
		}
		else if(item.Val1>=2)
		{
			if(item.Val4<=0||item.Val4>=3||Random(0,4)>=4||item.Val5>=3)
			{
				Kill(item);
				return false;
			}
		}
		else if(item.Val1<=1)
		{
			if(Random(0,4)>=4)
			{
				Kill(item);
				return false;
			}
		}
		return true;
	}
	
	bool Kill(Item&item)
	{
		CPlant@plant=GetCPlant(item.Val3);
		if(plant is null)
		return false;
		
		(item.Flags=((item.Flags)&(~((0x00000001)))));
		item.ChangeProto(plant.BasePid+plant.MaxCycle);
		item.Update();
		return true;
	}
	
	uint MakeShit(Item&item)
	{
		(item.Flags=((item.Flags)&(~((0x00000001)))));
		item.ChangeProto((1599));
		item.Update();
		return 0;
	}
	
	void IncreaseFruits(Item&item)
	{
		item.Val6+=1;
	}
	
	uint CycleDead(Item&item)
	{
		return 0;
	}
	
	uint Cycle1(Item&item)
	{
		return 0;
	}
	
	uint Cycle2(Item&item)
	{
		return 0;
	}
	
	uint Cycle3(Item&item)
	{
		return 0;
	}
	
	uint Cycle4(Item&item)
	{
		return 0;
	}
	
	uint Cycle5(Item&item)
	{
		return 0;
	}
}

uint e_ProcessPlant(uint[]@values)
{
	if(values is null||values.length()!=1)
	return 0;
	
	Item@item=GetItem(values[0]);
	
	if(item is null)
	return 0;
	
	uint16 pid=item.GetProtoId();
	
	if(item.GetType()!=(15))
	return 0;
	
	uint8 hashNum=item.Val3;
	CPlant@plant=GetCPlant(hashNum);
	
	if(item.Val1==0)
	item.SetEvent((5),null);
	else if(item.Val1>=plant.MaxCycle)
	{
		
		return plant.MakeShit(item);
	}
	
	if(item.Val1>0)
	{
		if(!plant.CheckWater(item))
		{
			item.Val1=plant.MaxCycle;
			return((1)*3600);
		}
		
		if(plant.ToShit[item.Val1-1]>=item.Val5)
		{
			item.Val2+=1;
			item.Val6+=1;
		}
		
		if(Random(1,95)==5)
		{
			Map@map=GetMap(item.MapId);
			if(!(map is null))
			{
				map.AddNpc(16,item.HexX,item.HexY,0,null,null,"mob@_MobInit");
				DeleteItem(item);
				return 0;
			}
			
		}
		
		item.Val4=0;
		item.Val5=0;
		
	}
	
	item.Val1+=1;
	uint Val1=item.Val1;
	
	uint8 cyclePic=Val1;    
	
	if(item.Val2<=2)
	item.Val2+=Random(0,1);
	else
	item.Val2+=Random(-2,2);   
	
	uint time=plant.Release(item); 
	
	return time;
}                                      

